FILE: .\boot.asm                        (0001) ;  Generated by PSoC Designer 5.4.2946
                                        (0002) ;
                                        (0003) ;@Id: boot.tpl#903 @
                                        (0004) ;=============================================================================
                                        (0005) ;  FILENAME:   boot.asm
                                        (0006) ;  Version:    4.40
                                        (0007) ;
                                        (0008) ;  DESCRIPTION:
                                        (0009) ;  M8C Boot Code for CY8C21x23 microcontroller family.
                                        (0010) ;
                                        (0011) ;  Copyright (c) Cypress Semiconductor 2013. All Rights Reserved.
                                        (0012) ;
                                        (0013) ; NOTES:
                                        (0014) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
                                        (0015) ; the project's root directory to create BOOT.ASM. Any changes made to
                                        (0016) ; BOOT.ASM will be  overwritten every time the project is generated; therefore
                                        (0017) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
                                        (0018) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
                                        (0019) ; are not accidentally modified.
                                        (0020) ;
                                        (0021) ;=============================================================================
                                        (0022) 
                                        (0023) include ".\lib\GlobalParams.inc"	;File generated by PSoC Designer (Project dependent)
                                        (0024) include "m8c.inc"			;Part specific file
                                        (0025) include "m8ssc.inc"			;Part specific file
                                        (0026) include "memory.inc"			;File generated by PSoC Designer (Project dependent)
                                        (0027) 
                                        (0028) ;--------------------------------------
                                        (0029) ; Export Declarations
                                        (0030) ;--------------------------------------
                                        (0031) 
                                        (0032) export __Start
                                        (0033) IF	(TOOLCHAIN & HITECH)
                                        (0034) ELSE
                                        (0035) export __bss_start
                                        (0036) export __data_start
                                        (0037) export __idata_start
                                        (0038) export __func_lit_start
                                        (0039) export __text_start
                                        (0040) ENDIF
                                        (0041) export  _bGetPowerSetting
                                        (0042) export   bGetPowerSetting
                                        (0043) 
                                        (0044) 
                                        (0045) ;--------------------------------------
                                        (0046) ; Optimization flags
                                        (0047) ;--------------------------------------
                                        (0048) ;
                                        (0049) ; To change the value of these flags, modify the file boot.tpl, not
                                        (0050) ; boot.asm. See the notes in the banner comment at the beginning of
                                        (0051) ; this file.
                                        (0052) 
                                        (0053) ; Optimization for Assembly language (only) projects and C-language projects
                                        (0054) ; that do not depend on the C compiler to initialize the values of RAM variables.
                                        (0055) ;   Set to 1: Support for C Run-time Environment initialization
                                        (0056) ;   Set to 0: Support for C not included. Faster start up, smaller code space.
                                        (0057) ;
                                        (0058) IF	(TOOLCHAIN & HITECH)
                                        (0059) ; The C compiler will customize the startup code - it's not required here
                                        (0060) 
                                        (0061) C_LANGUAGE_SUPPORT:              equ 0
                                        (0062) ELSE
                                        (0063) C_LANGUAGE_SUPPORT:              equ 1
                                        (0064) ENDIF
                                        (0065) 
                                        (0066) 
                                        (0067) ; For historical reasons, by default the boot code uses an lcall instruction
                                        (0068) ; to invoke the user's _main code. If _main executes a return instruction,
                                        (0069) ; boot provides an infinite loop. By changing the following equate from zero
                                        (0070) ; to 1, boot's lcall will be replaced by a ljmp instruction, saving two
                                        (0071) ; bytes on the stack which are otherwise required for the return address. If
                                        (0072) ; this option is enabled, _main must not return. (Beginning with the 4.2
                                        (0073) ; release, the C compiler automatically places an infinite loop at the end
                                        (0074) ; of main, rather than a return instruction.)
                                        (0075) ;
                                        (0076) ENABLE_LJMP_TO_MAIN:             equ 0
                                        (0077) 
                                        (0078) 
                                        (0079) ;-----------------------------------------------------------------------------
                                        (0080) ; Interrupt Vector Table
                                        (0081) ;-----------------------------------------------------------------------------
                                        (0082) ;
                                        (0083) ; Interrupt vector table entries are 4 bytes long.  Each one contains
                                        (0084) ; a jump instruction to an ISR (Interrupt Service Routine), although
                                        (0085) ; very short ISRs could be encoded within the table itself. Normally,
                                        (0086) ; vector jump targets are modified automatically according to the user
                                        (0087) ; modules selected. This occurs when the 'Generate Application' opera-
                                        (0088) ; tion is run causing PSoC Designer to create boot.asm and the other
                                        (0089) ; configuration files. If you need to hard code a vector, update the
                                        (0090) ; file boot.tpl, not boot.asm. See the banner comment at the beginning
                                        (0091) ; of this file.
                                        (0092) ;-----------------------------------------------------------------------------
                                        (0093) 
                                        (0094)     AREA TOP (ROM, ABS, CON)
                                        (0095) 
                                        (0096)     org   0                        ;Reset Interrupt Vector
                                        (0097) IF	(TOOLCHAIN & HITECH)
                                        (0098) ;   jmp   __Start                  ;C compiler fills in this vector
                                        (0099) ELSE
0000: 80 67    JMP   0x0068             (0100)     jmp   __Start                  ;First instruction executed following a Reset
                                        (0101) ENDIF
                                        (0102)     ;@PSoC_BOOT_ISR_UserCode_START@
                                        (0103)     ;---------------------------------------------------
                                        (0104)     ; Insert your custom code below this banner
                                        (0105)     ;---------------------------------------------------
                                        (0106) 
                                        (0107)     org   04h                      ;Low Voltage Detect (LVD) Interrupt Vector
0004: 30       HALT                     (0108)     halt                           ;Stop execution if power falls too low
                                        (0109) 
                                        (0110)     org   08h                      ;Analog Column 0 Interrupt Vector
                                        (0111)     // call	void_handler
0008: 7E       RETI                     (0112)     reti
                                        (0113) 
                                        (0114)     org   0Ch                      ;Analog Column 1 Interrupt Vector
                                        (0115)     // call	void_handler
000C: 7E       RETI                     (0116)     reti
                                        (0117) 
                                        (0118)     org   18h                      ;VC3 Interrupt Vector
                                        (0119)     // call	void_handler
0018: 7E       RETI                     (0120)     reti
                                        (0121) 
                                        (0122)     org   1Ch                      ;GPIO Interrupt Vector
001C: 7D 07 98 LJMP  PSoC_GPIO_ISR      (0123)     ljmp	PSoC_GPIO_ISR
001F: 7E       RETI                     (0124)     reti
                                        (0125) 
                                        (0126)     org   20h                      ;PSoC Block DBB00 Interrupt Vector
                                        (0127)     // call	void_handler
0020: 7E       RETI                     (0128)     reti
                                        (0129) 
                                        (0130)     org   24h                      ;PSoC Block DBB01 Interrupt Vector
0024: 7D 02 5F LJMP  _PWM16_1_ISR|_RX8_1_iReadChar|_RX8_1_cReadChar(0131)     ljmp	_PWM16_1_ISR
0027: 7E       RETI                     (0132)     reti
                                        (0133) 
                                        (0134)     org   28h                      ;PSoC Block DCB02 Interrupt Vector
0028: 7D 02 4A LJMP  _RX8_1_ISR         (0135)     ljmp	_RX8_1_ISR
002B: 7E       RETI                     (0136)     reti
                                        (0137) 
                                        (0138)     org   2Ch                      ;PSoC Block DCB03 Interrupt Vector
002C: 7D 02 77 LJMP  wPWM16_1_ReadCounter|_PWM16_1_wReadCounter|_wPWM16_1_ReadCounter|_wPWM16_1_ReadPulseWidth|_PWM16_1_wReadPulseWidth|wPWM16_1_ReadPulseWidth|_Counter8_1_ISR(0139)     ljmp	_Counter8_1_ISR
002F: 7E       RETI                     (0140)     reti
                                        (0141) 
                                        (0142)     org   60h                      ;PSoC I2C Interrupt Vector
                                        (0143)     // call	void_handler
0060: 7E       RETI                     (0144)     reti
                                        (0145) 
                                        (0146)     org   64h                      ;Sleep Timer Interrupt Vector
                                        (0147)     // call	void_handler
0064: 7E       RETI                     (0148)     reti
0068: 71 10    OR    F,0x10             
                                        (0149)     ;---------------------------------------------------
                                        (0150)     ; Insert your custom code above this banner
                                        (0151)     ;---------------------------------------------------
                                        (0152)     ;@PSoC_BOOT_ISR_UserCode_END@
                                        (0153) 
                                        (0154) ;-----------------------------------------------------------------------------
                                        (0155) ;  Start of Execution.
                                        (0156) ;-----------------------------------------------------------------------------
                                        (0157) ;  The Supervisory ROM SWBootReset function has already completed the
                                        (0158) ;  calibrate1 process, loading trim values for 5 volt operation.
                                        (0159) ;
                                        (0160) 
                                        (0161) IF	(TOOLCHAIN & HITECH)
                                        (0162)  	AREA PD_startup(CODE, REL, CON)
                                        (0163) ELSE
                                        (0164)     org 68h
                                        (0165) ENDIF
                                        (0166) __Start:
                                        (0167) 
                                        (0168)     ; initialize SMP values for voltage stabilization, if required,
                                        (0169)     ; leaving power-on reset (POR) level at the default (low) level, at
                                        (0170)     ; least for now. 
                                        (0171)     ;
                                        (0172)     M8C_SetBank1
006A: 62 E3 82 MOV   REG[0xE3],0x82     (0173)     mov   reg[VLT_CR], SWITCH_MODE_PUMP_JUST | LVD_TBEN_JUST | TRIP_VOLTAGE_JUST
006D: 70 EF    AND   F,0xEF             
006F: 62 E3 38 MOV   REG[0xE3],0x38     
                                        (0174)     M8C_SetBank0
                                        (0175) 
                                        (0176) M8C_ClearWDTAndSleep			   ; Clear WDT before enabling it.
                                        (0177) IF ( WATCHDOG_ENABLE )             ; WDT selected in Global Params
                                        (0178)     M8C_EnableWatchDog
                                        (0179) ENDIF
                                        (0180) 
0072: 41 FE FB AND   REG[0xFE],0xFB     (0181)     and  reg[CPU_SCR1], ~CPU_SCR1_ECO_ALLOWED  ; Prevent ECO from being enabled
                                        (0182) 
                                        (0183) IF	(TOOLCHAIN & HITECH)
                                        (0184)     ;---------------------------
                                        (0185)     ; Set up the Temporary stack
                                        (0186)     ;---------------------------
                                        (0187)     ; A temporary stack is set up for the SSC instructions.
                                        (0188)     ; The real stack start will be assigned later.
                                        (0189)     ;
                                        (0190) 	global		__Lstackps
                                        (0191) 	mov     a,low __Lstackps
                                        (0192) 	swap    a,sp
                                        (0193) ELSE
                                        (0194)     ;------------------
                                        (0195)     ; Set up the stack
                                        (0196)     ;------------------
0075: 50 3D    MOV   A,0x3D             (0197)     mov   A, __ramareas_end        ; Set top of stack to end of used RAM
0077: 4E       SWAP  SP,A               (0198)     swap  SP, A                    ; This is only temporary if going to LMM
0078: 62 E3 38 MOV   REG[0xE3],0x38     
                                        (0199) ENDIF
                                        (0200) 
                                        (0201)     ;-----------------------------------------------
                                        (0202)     ; Set Power-related Trim.
                                        (0203)     ;-----------------------------------------------
                                        (0204) M8C_ClearWDTAndSleep ; Clear WDT before enabling it.
                                        (0205) IF ( POWER_SETTING & POWER_SET_5V0)            ; *** 5.0 Volt operation   ***
                                        (0206)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                        (0207)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0208)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_5V_6MHZ, 1, SSCTBL1_TRIM_BGR_5V
                                        (0209)  ENDIF
                                        (0210) ENDIF ; 5.0 V Operation
                                        (0211) 
                                        (0212) IF ( POWER_SETTING & POWER_SET_3V3)            ; *** 3.3 Volt operation   ***
                                        (0213)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                        (0214)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0215)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_3V_6MHZ, 1, SSCTBL1_TRIM_BGR_3V
                                        (0216)  ELSE                                          ; *** 12MHZ Main Oscillator ***
                                        (0217)     M8SSC_SetTableTrims  1, SSCTBL1_TRIM_IMO_3V_24MHZ, SSCTBL1_TRIM_BGR_3V
                                        (0218)  ENDIF
                                        (0219) ENDIF ; 3.3 Volt Operation
                                        (0220) 
                                        (0221) IF ( POWER_SETTING & POWER_SET_2V7_12MHZ)      ; *** 2.7 Volts / 12MHZ operation ***
                                        (0222)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0223)     M8SSC_SetTableTrims  2, SSCTBL2_TRIM_IMO_2V_12MHZ, SSCTBL2_TRIM_BGR_2V
                                        (0224) ENDIF ; *** 2.7 Volts / 12MHZ operation ***
                                        (0225) 
                                        (0226) IF ( POWER_SETTING & POWER_SET_2V7_6MHZ)       ; *** 2.7 Volts /  6MHZ operation ***
                                        (0227)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0228)     M8SSC_SetTableTrims  2, SSCTBL2_TRIM_IMO_2V_6MHZ,  SSCTBL2_TRIM_BGR_2V
                                        (0229) ENDIF ; *** 2.7 Volts /  6MHZ operation ***
                                        (0230) 
007B: 55 F8 00 MOV   [_ramareas_end+187],0x0(0231)     mov  [bSSC_KEY1],  0           ; Lock out Flash and Supervisiory operations
007E: 55 F9 00 MOV   [_ramareas_end+188],0x0(0232)     mov  [bSSC_KEYSP], 0
0081: 71 10    OR    F,0x10             
                                        (0233) 
                                        (0234)     ;---------------------------------------
                                        (0235)     ; Initialize Crystal Oscillator and PLL
                                        (0236)     ;---------------------------------------
                                        (0237) IF ( POWER_SETTING & POWER_SET_2V7)       ; *** 2.7 Volts  ***
                                        (0238)     M8C_SetBank1
                                        (0239)     mov   reg[OSC_CR0], (SLEEP_TIMER_JUST | OSC_CR0_CPU_3MHz)
                                        (0240)     M8C_SetBank0
                                        (0241)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                        (0242) 
                                        (0243) ELSE 	 ;*** all other voltages OK for 12Mhz ***
                                        (0244)     M8C_SetBank1
0083: 62 E0 02 MOV   REG[0xE0],0x2      (0245)     mov   reg[OSC_CR0], (SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
0086: 70 EF    AND   F,0xEF             
0088: 62 E3 38 MOV   REG[0xE3],0x38     
                                        (0246)     M8C_SetBank0
                                        (0247)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                        (0248) 
                                        (0249) ENDIF
                                        (0250) 
                                        (0251)     ;-------------------------------------------------------
                                        (0252)     ; Initialize Proper Drive Mode for External Clock Pin
                                        (0253)     ;-------------------------------------------------------
                                        (0254) 
                                        (0255)     ; Change EXTCLK pin from Hi-Z Analog (110b) drive mode to Hi-Z (010b) drive mode
                                        (0256) 
                                        (0257) IF (SYSCLK_SOURCE)
                                        (0258)     and reg[PRT1DM2],  ~0x10        ; Clear bit 4 of EXTCLK pin's DM2 register 
                                        (0259) ENDIF
                                        (0260)     ; EXTCLK pin is now in proper drive mode to input the external clock signal
                                        (0261) 
                                        (0262)     ;@PSoC_BOOT_LOADCFG_UserCode_START@
                                        (0263)     ;---------------------------------------------------
                                        (0264)     ; Insert your custom code below this banner
                                        (0265)     ;---------------------------------------------------
                                        (0266) 
                                        (0267)     ;---------------------------------------------------
                                        (0268)     ; Insert your custom code above this banner
                                        (0269)     ;---------------------------------------------------
                                        (0270)     ;@PSoC_BOOT_LOADCFG_UserCode_END@ 
                                        (0271) 
                                        (0272)     ;-------------------------
                                        (0273)     ; Load Base Configuration
                                        (0274)     ;-------------------------
                                        (0275)     ; Load global parameter settings and load the user modules in the
                                        (0276)     ; base configuration. Exceptions: (1) Leave CPU Speed fast as possible
                                        (0277)     ; to minimize start up time; (2) We may still need to play with the
                                        (0278)     ; Sleep Timer.
                                        (0279)     ;
008B: 7C 02 40 LCALL 0x0240             (0280)     lcall LoadConfigInit
                                        (0281) 
                                        (0282)     ;-----------------------------------
                                        (0283)     ; Initialize C Run-Time Environment
                                        (0284)     ;-----------------------------------
                                        (0285) IF ( C_LANGUAGE_SUPPORT )
008E: 50 00    MOV   A,0x0              (0286)     mov  A,0                           ; clear the 'bss' segment to zero
0090: 55 17 18 MOV   [__r0],0x18        (0287)     mov  [__r0],<__bss_start
                                        (0288) BssLoop:
0093: 3C 17 3D CMP   [__r0],0x3D        (0289)     cmp  [__r0],<__bss_end
0096: A0 05    JZ    0x009C             (0290)     jz   BssDone
0098: 3F 17    MVI   [__r0],A           (0291)     mvi  [__r0],A
009A: 8F F8    JMP   0x0093             (0292)     jmp  BssLoop
                                        (0293) BssDone:
009C: 50 01    MOV   A,0x1              (0294)     mov  A,>__idata_start              ; copy idata to data segment
009E: 57 50    MOV   X,0x50             (0295)     mov  X,<__idata_start
00A0: 55 17 00 MOV   [__r0],0x0         (0296)     mov  [__r0],<__data_start
                                        (0297) IDataLoop:
00A3: 3C 17 09 CMP   [__r0],0x9         (0298)     cmp  [__r0],<__data_end
00A6: A0 0B    JZ    0x00B2             (0299)     jz   C_RTE_Done
00A8: 08       PUSH  A                  (0300)     push A
00A9: 28       ROMX                     (0301)     romx
00AA: 3F 17    MVI   [__r0],A           (0302)     mvi  [__r0],A
00AC: 18       POP   A                  (0303)     pop  A
00AD: 75       INC   X                  (0304)     inc  X
00AE: 09 00    ADC   A,0x0              (0305)     adc  A,0
00B0: 8F F2    JMP   0x00A3             (0306)     jmp  IDataLoop
00B2: 71 10    OR    F,0x10             
                                        (0307) 
                                        (0308) C_RTE_Done:
                                        (0309) 
                                        (0310) ENDIF ; C_LANGUAGE_SUPPORT
                                        (0311) 
                                        (0312)     ;-------------------------------
                                        (0313)     ; Voltage Stabilization for SMP
                                        (0314)     ;-------------------------------
                                        (0315) 
                                        (0316) IF ( POWER_SETTING & POWER_SET_5V0)    ; 5.0V Operation
                                        (0317) IF ( SWITCH_MODE_PUMP ^ 1 )            ; SMP is operational
                                        (0318)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0319)     ; When using the SMP at 5V, we must wait for Vdd to slew from 3.1V to
                                        (0320)     ; 5V before enabling the Precision Power-On Reset (PPOR).
                                        (0321)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0322)     or   reg[INT_MSK0],INT_MSK0_SLEEP
                                        (0323)     M8C_SetBank1
                                        (0324)     and   reg[OSC_CR0], ~OSC_CR0_SLEEP
                                        (0325)     or    reg[OSC_CR0],  OSC_CR0_SLEEP_512Hz
                                        (0326)     M8C_SetBank0
                                        (0327)     M8C_ClearWDTAndSleep                   ; Restart the sleep timer
                                        (0328)     mov   reg[INT_VC], 0                   ; Clear all pending interrupts
                                        (0329) .WaitFor2ms:
                                        (0330)     tst   reg[INT_CLR0], INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
                                        (0331)     jz   .WaitFor2ms                       ; Branch fails when 2 msec has passed
                                        (0332) ENDIF ; SMP is operational
                                        (0333) ENDIF ; 5.0V Operation
                                        (0334) 
                                        (0335)     ;-------------------------------
                                        (0336)     ; Set Power-On Reset (POR) Level
                                        (0337)     ;-------------------------------
                                        (0338)     ;  The writes to the VLT_CR register below include setting the POR to VLT_CR_POR_HIGH,
                                        (0339)     ;  VLT_CR_POR_MID or VLT_CR_POR_LOW. Correctly setting this value is critical to the proper
                                        (0340)     ;  operation of the PSoC. The POR protects the M8C from mis-executing when Vdd falls low. 
                                        (0341)     ;  These values should not be changed from the settings here. See Section "POR and LVD" of 
                                        (0342)     ;  Technical Reference Manual #001-14463 for more information.
                                        (0343) 
                                        (0344)     M8C_SetBank1
                                        (0345) 
                                        (0346) IF (POWER_SETTING & POWER_SET_2V7)             ; 2.7V Operation?
                                        (0347)                                                ;  Yes, lowest trip already set
                                        (0348) ELSE                                           ;   No, must adjust POR...
                                        (0349) IF (POWER_SETTING & POWER_SET_3V3)             ; 3.3V Operation?
                                        (0350)     or   reg[VLT_CR], VLT_CR_POR_MID           ;   Yes, change to midpoint trip
                                        (0351) ELSE
                                        (0352) IF (POWER_SETTING & POWER_SET_5V0)             ; 5.0V Operation?
                                        (0353)  IF (POWER_SETTING & POWER_SET_SLOW_IMO)       ; and Slow Mode?
                                        (0354)     or   reg[VLT_CR], VLT_CR_POR_MID           ;   Yes, set to midpoint trip
                                        (0355)  ELSE                                          ;    No, fast mode
                                        (0356)   IF ( CPU_CLOCK_JUST ^ OSC_CR0_CPU_24MHz )    ;      As fast as 24MHz?
00B4: 43 E3 10 OR    REG[0xE3],0x10     (0357)     or   reg[VLT_CR], VLT_CR_POR_MID           ;         No, change to midpoint trip
00B7: 70 EF    AND   F,0xEF             
                                        (0358)   ELSE ; 24HMz                                 ;
                                        (0359)     or    reg[VLT_CR], VLT_CR_POR_HIGH         ;        Yes, switch to	highest setting
                                        (0360)   ENDIF ; 24MHz
                                        (0361)  ENDIF ; Slow Mode
                                        (0362) ENDIF ; 5.0V Operation
                                        (0363) ENDIF ; 3.3V Operation
                                        (0364) ENDIF ; 2.7V Operation
                                        (0365) 
                                        (0366)     M8C_SetBank0
                                        (0367) 
                                        (0368)     ;----------------------------
                                        (0369)     ; Wrap up and invoke "main"
                                        (0370)     ;----------------------------
                                        (0371) 
                                        (0372)     ; Disable the Sleep interrupt that was used for timing above.  In fact,
                                        (0373)     ; no interrupts should be enabled now, so may as well clear the register.
                                        (0374)     ;
00B9: 62 E0 00 MOV   REG[0xE0],0x0      (0375)     mov  reg[INT_MSK0],0
00BC: 71 10    OR    F,0x10             
                                        (0376) 
                                        (0377)     ; Everything has started OK. Now select requested CPU & sleep frequency.
                                        (0378)     ;
                                        (0379)     M8C_SetBank1
00BE: 62 E0 02 MOV   REG[0xE0],0x2      (0380)     mov  reg[OSC_CR0],(SLEEP_TIMER_JUST | CPU_CLOCK_JUST)
00C1: 70 EF    AND   F,0xEF             
                                        (0381)     M8C_SetBank0
                                        (0382) 
                                        (0383)     ; Global Interrupt are NOT enabled, this should be done in main().
                                        (0384)     ; LVD is set but will not occur unless Global Interrupts are enabled.
                                        (0385)     ; Global Interrupts should be enabled as soon as possible in main().
                                        (0386)     ;
00C3: 62 E2 00 MOV   REG[0xE2],0x0      (0387)     mov  reg[INT_VC],0             ; Clear any pending interrupts which may
                                        (0388)                                    ; have been set during the boot process.
                                        (0389) IF	(TOOLCHAIN & HITECH)
                                        (0390) 	ljmp  startup                  ; Jump to C compiler startup code
                                        (0391) ELSE
                                        (0392) IF ENABLE_LJMP_TO_MAIN
                                        (0393)     ljmp  _main                    ; goto main (no return)
                                        (0394) ELSE
00C6: 7C 04 BE LCALL _main              (0395)     lcall _main                    ; call main
                                        (0396) .Exit:
00C9: 8F FF    JMP   0x00C9             (0397)     jmp  .Exit                     ; Wait here after return till power-off or reset
                                        (0398) ENDIF
                                        (0399) ENDIF ; TOOLCHAIN
                                        (0400) 
                                        (0401)     ;---------------------------------
                                        (0402)     ; Library Access to Global Parms
                                        (0403)     ;---------------------------------
                                        (0404)     ;
                                        (0405)  bGetPowerSetting:
                                        (0406) _bGetPowerSetting:
                                        (0407)     ; Returns value of POWER_SETTING in the A register.
                                        (0408)     ; No inputs. No Side Effects.
                                        (0409)     ;
                                        (0410) IF (POWER_SETTING & POWER_SET_2V7)
                                        (0411)     mov   A, POWER_SETTING | POWER_SET_SLOW_IMO
                                        (0412) ELSE
00CB: 50 10    MOV   A,0x10             (0413)     mov   A, POWER_SETTING          ; Supply voltage and internal main osc
                                        (0414) ENDIF
00CD: 7F       RET                      (0415)     ret
                                        (0416) 
                                        (0417) IF	(TOOLCHAIN & HITECH)
                                        (0418) ELSE
                                        (0419)     ;---------------------------------
                                        (0420)     ; Order Critical RAM & ROM AREAs
                                        (0421)     ;---------------------------------
                                        (0422)     ;  'TOP' is all that has been defined so far...
                                        (0423) 
                                        (0424)     ;  ROM AREAs for C CONST, static & global items
                                        (0425)     ;
                                        (0426)     AREA lit               (ROM, REL, CON, LIT)   ; 'const' definitions
                                        (0427)     AREA idata             (ROM, REL, CON, LIT)   ; Constants for initializing RAM
                                        (0428) __idata_start:
                                        (0429) 
                                        (0430)     AREA func_lit          (ROM, REL, CON, proclab)   ; Function Pointers
                                        (0431) __func_lit_start:
                                        (0432) 
                                        (0433)     AREA psoc_config       (ROM, REL, CON)   ; Configuration Load & Unload
                                        (0434)     AREA UserModules       (ROM, REL, CON)   ; User Module APIs
                                        (0435) 
                                        (0436)     ; CODE segment for general use
                                        (0437)     ;
                                        (0438)     AREA text (ROM, REL, CON)
                                        (0439) __text_start:
                                        (0440) 
                                        (0441)     ; RAM area usage
                                        (0442)     ;
                                        (0443)     AREA data              (RAM, REL, CON)   ; initialized RAM
                                        (0444) __data_start:
                                        (0445) 
                                        (0446)     AREA virtual_registers (RAM, REL, CON)   ; Temp vars of C compiler
                                        (0447)     AREA InterruptRAM      (RAM, REL, CON)   ; Interrupts, on Page 0
                                        (0448)     AREA bss               (RAM, REL, CON)   ; general use
                                        (0449) __bss_start:
                                        (0450) 
                                        (0451) ENDIF ; TOOLCHAIN
                                        (0452) 
                                        (0453) ; end of file boot.asm
FILE: lib\psocconfigtbl.asm             (0001) ;  Generated by PSoC Designer 5.4.2946
0159: 70 EF    AND   F,0xEF             (0002) ;
                                        (0003) ; =============================================================================
                                        (0004) ; FILENAME: PSoCConfigTBL.asm
                                        (0005) ;  
                                        (0006) ; Copyright (c) Cypress Semiconductor 2013. All Rights Reserved.
                                        (0007) ;  
                                        (0008) ; NOTES:
                                        (0009) ; Do not modify this file. It is generated by PSoC Designer each time the
                                        (0010) ; generate application function is run. The values of the parameters in this
                                        (0011) ; file can be modified by changing the values of the global parameters in the
                                        (0012) ; device editor.
                                        (0013) ;  
                                        (0014) ; =============================================================================
                                        (0015)  
                                        (0016) include "m8c.inc"
                                        (0017) ;  Personalization tables 
                                        (0018) export LoadConfigTBL_pdproject2
                                        (0019) AREA psoc_config(rom, rel)
                                        (0020) LoadConfigTBL_pdproject2:
                                        (0021) 	M8C_SetBank0
                                        (0022) ;  Global Register values Bank 0
015B: 62 60 09 MOV   REG[0x60],0x9      (0023) 	mov	reg[60h], 09h		; AnalogColumnInputSelect register (AMX_IN)
015E: 62 64 00 MOV   REG[0x64],0x0      (0024) 	mov	reg[64h], 00h		; AnalogComparatorControl0 register (CMP_CR0)
0161: 62 66 00 MOV   REG[0x66],0x0      (0025) 	mov	reg[66h], 00h		; AnalogComparatorControl1 register (CMP_CR1)
0164: 62 E6 00 MOV   REG[0xE6],0x0      (0026) 	mov	reg[e6h], 00h		; DecimatorControl_0 register (DEC_CR0)
0167: 62 E7 00 MOV   REG[0xE7],0x0      (0027) 	mov	reg[e7h], 00h		; DecimatorControl_1 register (DEC_CR1)
016A: 62 D6 00 MOV   REG[0xD6],0x0      (0028) 	mov	reg[d6h], 00h		; I2CConfig register (I2CCFG)
016D: 62 62 00 MOV   REG[0x62],0x0      (0029) 	mov	reg[62h], 00h		; PWM_Control register (PWM_CR)
0170: 62 B0 04 MOV   REG[0xB0],0x4      (0030) 	mov	reg[b0h], 04h		; Row_0_InputMux register (RDI0RI)
0173: 62 B1 00 MOV   REG[0xB1],0x0      (0031) 	mov	reg[b1h], 00h		; Row_0_InputSync register (RDI0SYN)
0176: 62 B2 00 MOV   REG[0xB2],0x0      (0032) 	mov	reg[b2h], 00h		; Row_0_LogicInputAMux register (RDI0IS)
0179: 62 B3 CF MOV   REG[0xB3],0xCF     (0033) 	mov	reg[b3h], cfh		; Row_0_LogicSelect_0 register (RDI0LT0)
017C: 62 B4 33 MOV   REG[0xB4],0x33     (0034) 	mov	reg[b4h], 33h		; Row_0_LogicSelect_1 register (RDI0LT1)
017F: 62 B5 22 MOV   REG[0xB5],0x22     (0035) 	mov	reg[b5h], 22h		; Row_0_OutputDrive_0 register (RDI0SRO0)
0182: 62 B6 00 MOV   REG[0xB6],0x0      (0036) 	mov	reg[b6h], 00h		; Row_0_OutputDrive_1 register (RDI0SRO1)
                                        (0037) ;  Instance name Counter8_1, User Module Counter8
                                        (0038) ;       Instance name Counter8_1, Block Name CNTR8(DCB03)
0185: 62 2F 00 MOV   REG[0x2F],0x0      (0039) 	mov	reg[2fh], 00h		;Counter8_1_CONTROL_REG(DCB03CR0)
0188: 62 2D 7D MOV   REG[0x2D],0x7D     (0040) 	mov	reg[2dh], 7dh		;Counter8_1_PERIOD_REG(DCB03DR1)
018B: 62 2E 00 MOV   REG[0x2E],0x0      (0041) 	mov	reg[2eh], 00h		;Counter8_1_COMPARE_REG(DCB03DR2)
                                        (0042) ;  Instance name PWM16_1, User Module PWM16
                                        (0043) ;       Instance name PWM16_1, Block Name PWM16_LSB(DBB00)
018E: 62 23 00 MOV   REG[0x23],0x0      (0044) 	mov	reg[23h], 00h		;PWM16_1_CONTROL_LSB_REG(DBB00CR0)
0191: 62 21 C8 MOV   REG[0x21],0xC8     (0045) 	mov	reg[21h], c8h		;PWM16_1_PERIOD_LSB_REG(DBB00DR1)
0194: 62 22 C8 MOV   REG[0x22],0xC8     (0046) 	mov	reg[22h], c8h		;PWM16_1_COMPARE_LSB_REG(DBB00DR2)
                                        (0047) ;       Instance name PWM16_1, Block Name PWM16_MSB(DBB01)
0197: 62 27 00 MOV   REG[0x27],0x0      (0048) 	mov	reg[27h], 00h		;PWM16_1_CONTROL_MSB_REG(DBB01CR0)
019A: 62 25 08 MOV   REG[0x25],0x8      (0049) 	mov	reg[25h], 08h		;PWM16_1_PERIOD_MSB_REG(DBB01DR1)
019D: 62 26 00 MOV   REG[0x26],0x0      (0050) 	mov	reg[26h], 00h		;PWM16_1_COMPARE_MSB_REG(DBB01DR2)
                                        (0051) ;  Instance name RX8_1, User Module RX8
                                        (0052) ;       Instance name RX8_1, Block Name RX8(DCB02)
01A0: 62 2B 00 MOV   REG[0x2B],0x0      (0053) 	mov	reg[2bh], 00h		;RX8_1_CONTROL_REG  (DCB02CR0)
01A3: 62 29 00 MOV   REG[0x29],0x0      (0054) 	mov	reg[29h], 00h		;RX8_1_(DCB02DR1)
01A6: 62 2A 00 MOV   REG[0x2A],0x0      (0055) 	mov	reg[2ah], 00h		;RX8_1_RX_BUFFER_REG(DCB02DR2)
01A9: 71 10    OR    F,0x10             
                                        (0056) 	M8C_SetBank1
                                        (0057) ;  Global Register values Bank 1
01AB: 62 61 00 MOV   REG[0x61],0x0      (0058) 	mov	reg[61h], 00h		; AnalogClockSelect1 register (CLK_CR1)
01AE: 62 60 00 MOV   REG[0x60],0x0      (0059) 	mov	reg[60h], 00h		; AnalogColumnClockSelect register (CLK_CR0)
01B1: 62 62 00 MOV   REG[0x62],0x0      (0060) 	mov	reg[62h], 00h		; AnalogIOControl_0 register (ABF_CR0)
01B4: 62 67 33 MOV   REG[0x67],0x33     (0061) 	mov	reg[67h], 33h		; AnalogLUTControl0 register (ALT_CR0)
01B7: 62 64 00 MOV   REG[0x64],0x0      (0062) 	mov	reg[64h], 00h		; ComparatorGlobalOutEn register (CMP_GO_EN)
01BA: 62 D1 00 MOV   REG[0xD1],0x0      (0063) 	mov	reg[d1h], 00h		; GlobalDigitalInterconnect_Drive_Even_Input register (GDI_E_IN)
01BD: 62 D3 00 MOV   REG[0xD3],0x0      (0064) 	mov	reg[d3h], 00h		; GlobalDigitalInterconnect_Drive_Even_Output register (GDI_E_OU)
01C0: 62 D0 00 MOV   REG[0xD0],0x0      (0065) 	mov	reg[d0h], 00h		; GlobalDigitalInterconnect_Drive_Odd_Input register (GDI_O_IN)
01C3: 62 D2 00 MOV   REG[0xD2],0x0      (0066) 	mov	reg[d2h], 00h		; GlobalDigitalInterconnect_Drive_Odd_Output register (GDI_O_OU)
01C6: 62 E1 BF MOV   REG[0xE1],0xBF     (0067) 	mov	reg[e1h], bfh		; OscillatorControl_1 register (OSC_CR1)
01C9: 62 E2 00 MOV   REG[0xE2],0x0      (0068) 	mov	reg[e2h], 00h		; OscillatorControl_2 register (OSC_CR2)
01CC: 62 DF 19 MOV   REG[0xDF],0x19     (0069) 	mov	reg[dfh], 19h		; OscillatorControl_3 register (OSC_CR3)
01CF: 62 DE 00 MOV   REG[0xDE],0x0      (0070) 	mov	reg[deh], 00h		; OscillatorControl_4 register (OSC_CR4)
01D2: 62 DD 00 MOV   REG[0xDD],0x0      (0071) 	mov	reg[ddh], 00h		; OscillatorGlobalBusEnableControl register (OSC_GO_EN)
                                        (0072) ;  Instance name Counter8_1, User Module Counter8
                                        (0073) ;       Instance name Counter8_1, Block Name CNTR8(DCB03)
01D5: 62 2C 31 MOV   REG[0x2C],0x31     (0074) 	mov	reg[2ch], 31h		;Counter8_1_FUNC_REG(DCB03FN)
01D8: 62 2D 16 MOV   REG[0x2D],0x16     (0075) 	mov	reg[2dh], 16h		;Counter8_1_INPUT_REG(DCB03IN)
01DB: 62 2E 45 MOV   REG[0x2E],0x45     (0076) 	mov	reg[2eh], 45h		;Counter8_1_OUTPUT_REG(DCB03OU)
                                        (0077) ;  Instance name PWM16_1, User Module PWM16
                                        (0078) ;       Instance name PWM16_1, Block Name PWM16_LSB(DBB00)
01DE: 62 20 11 MOV   REG[0x20],0x11     (0079) 	mov	reg[20h], 11h		;PWM16_1_FUNC_LSB_REG(DBB00FN)
01E1: 62 21 15 MOV   REG[0x21],0x15     (0080) 	mov	reg[21h], 15h		;PWM16_1_INPUT_LSB_REG(DBB00IN)
01E4: 62 22 40 MOV   REG[0x22],0x40     (0081) 	mov	reg[22h], 40h		;PWM16_1_OUTPUT_LSB_REG(DBB00OU)
                                        (0082) ;       Instance name PWM16_1, Block Name PWM16_MSB(DBB01)
01E7: 62 24 39 MOV   REG[0x24],0x39     (0083) 	mov	reg[24h], 39h		;PWM16_1_FUNC_MSB_REG(DBB01FN)
01EA: 62 25 35 MOV   REG[0x25],0x35     (0084) 	mov	reg[25h], 35h		;PWM16_1_INPUT_MSB_REG(DBB01IN)
01ED: 62 26 44 MOV   REG[0x26],0x44     (0085) 	mov	reg[26h], 44h		;PWM16_1_OUTPUT_MSB_REG(DBB01OU)
                                        (0086) ;  Instance name RX8_1, User Module RX8
                                        (0087) ;       Instance name RX8_1, Block Name RX8(DCB02)
01F0: 62 28 05 MOV   REG[0x28],0x5      (0088) 	mov	reg[28h], 05h		;RX8_1_FUNC_REG     (DCB02FN)
01F3: 62 29 D1 MOV   REG[0x29],0xD1     (0089) 	mov	reg[29h], d1h		;RX8_1_INPUT_REG    (DCB02IN)
01F6: 62 2A 40 MOV   REG[0x2A],0x40     (0090) 	mov	reg[2ah], 40h		;RX8_1_OUTPUT_REG   (DCB02OU)
01F9: 70 EF    AND   F,0xEF             
01FB: 70 EF    AND   F,0xEF             
                                        (0091) 	M8C_SetBank0
                                        (0092) ;  Ordered Global Register values
                                        (0093) 	M8C_SetBank0
01FD: 62 00 10 MOV   REG[0x0],0x10      (0094) 	mov	reg[00h], 10h		; Port_0_Data register (PRT0DR)
0200: 71 10    OR    F,0x10             
                                        (0095) 	M8C_SetBank1
0202: 62 00 14 MOV   REG[0x0],0x14      (0096) 	mov	reg[00h], 14h		; Port_0_DriveMode_0 register (PRT0DM0)
0205: 62 01 28 MOV   REG[0x1],0x28      (0097) 	mov	reg[01h], 28h		; Port_0_DriveMode_1 register (PRT0DM1)
0208: 70 EF    AND   F,0xEF             
                                        (0098) 	M8C_SetBank0
020A: 62 03 08 MOV   REG[0x3],0x8       (0099) 	mov	reg[03h], 08h		; Port_0_DriveMode_2 register (PRT0DM2)
020D: 62 02 30 MOV   REG[0x2],0x30      (0100) 	mov	reg[02h], 30h		; Port_0_GlobalSelect register (PRT0GS)
0210: 71 10    OR    F,0x10             
                                        (0101) 	M8C_SetBank1
0212: 62 02 00 MOV   REG[0x2],0x0       (0102) 	mov	reg[02h], 00h		; Port_0_IntCtrl_0 register (PRT0IC0)
0215: 62 03 10 MOV   REG[0x3],0x10      (0103) 	mov	reg[03h], 10h		; Port_0_IntCtrl_1 register (PRT0IC1)
0218: 70 EF    AND   F,0xEF             
                                        (0104) 	M8C_SetBank0
021A: 62 01 10 MOV   REG[0x1],0x10      (0105) 	mov	reg[01h], 10h		; Port_0_IntEn register (PRT0IE)
021D: 62 04 03 MOV   REG[0x4],0x3       (0106) 	mov	reg[04h], 03h		; Port_1_Data register (PRT1DR)
0220: 71 10    OR    F,0x10             
                                        (0107) 	M8C_SetBank1
0222: 62 04 03 MOV   REG[0x4],0x3       (0108) 	mov	reg[04h], 03h		; Port_1_DriveMode_0 register (PRT1DM0)
0225: 62 05 01 MOV   REG[0x5],0x1       (0109) 	mov	reg[05h], 01h		; Port_1_DriveMode_1 register (PRT1DM1)
0228: 70 EF    AND   F,0xEF             
                                        (0110) 	M8C_SetBank0
022A: 62 07 00 MOV   REG[0x7],0x0       (0111) 	mov	reg[07h], 00h		; Port_1_DriveMode_2 register (PRT1DM2)
022D: 62 06 00 MOV   REG[0x6],0x0       (0112) 	mov	reg[06h], 00h		; Port_1_GlobalSelect register (PRT1GS)
0230: 71 10    OR    F,0x10             
                                        (0113) 	M8C_SetBank1
0232: 62 06 00 MOV   REG[0x6],0x0       (0114) 	mov	reg[06h], 00h		; Port_1_IntCtrl_0 register (PRT1IC0)
0235: 62 07 00 MOV   REG[0x7],0x0       (0115) 	mov	reg[07h], 00h		; Port_1_IntCtrl_1 register (PRT1IC1)
0238: 70 EF    AND   F,0xEF             
                                        (0116) 	M8C_SetBank0
023A: 62 05 00 MOV   REG[0x5],0x0       (0117) 	mov	reg[05h], 00h		; Port_1_IntEn register (PRT1IE)
023D: 70 EF    AND   F,0xEF             
                                        (0118) 	M8C_SetBank0
023F: 7F       RET                      (0119) 	ret
                                        (0120) 
                                        (0121) 
                                        (0122) ; PSoC Configuration file trailer PsocConfig.asm
FILE: lib\psocconfig.asm                (0001) ;  Generated by PSoC Designer 5.4.2946
                                        (0002) ;
                                        (0003) ;==========================================================================
                                        (0004) ;  PSoCConfig.asm
                                        (0005) ;  @PSOC_VERSION
                                        (0006) ;
                                        (0007) ;  Version: 0.85
                                        (0008) ;  Revised: June 22, 2004
                                        (0009) ;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0010) ;
                                        (0011) ;  This file is generated by the Device Editor on Application Generation.
                                        (0012) ;  It contains code which loads the configuration data table generated in
                                        (0013) ;  the file PSoCConfigTBL.asm
                                        (0014) ;
                                        (0015) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                        (0016) ;  Edits to this file will not be preserved.
                                        (0017) ;==========================================================================
                                        (0018) ;
                                        (0019) include "m8c.inc"
                                        (0020) include "memory.inc"
                                        (0021) include "GlobalParams.inc"
                                        (0022) 
                                        (0023) export LoadConfigInit
                                        (0024) export _LoadConfigInit
                                        (0025) export LoadConfig_pdproject2
                                        (0026) export _LoadConfig_pdproject2
                                        (0027) 
                                        (0028) export NO_SHADOW
                                        (0029) export _NO_SHADOW
                                        (0030) 
                                        (0031) FLAG_CFG_MASK:      equ 10h         ;M8C flag register REG address bit mask
                                        (0032) END_CONFIG_TABLE:   equ ffh         ;end of config table indicator
                                        (0033) 
                                        (0034) AREA psoc_config(rom, rel)
                                        (0035) 
                                        (0036) 
                                        (0037) ;---------------------------------------------------------------------------
                                        (0038) ; LoadConfigInit - Establish the start-up configuration (except for a few
                                        (0039) ;                  parameters handled by boot code, like CPU speed). This
                                        (0040) ;                  function can be called from user code, but typically it
                                        (0041) ;                  is only called from boot.
                                        (0042) ;
                                        (0043) ;       INPUTS: None.
                                        (0044) ;      RETURNS: Nothing.
                                        (0045) ; SIDE EFFECTS: Registers are volatile: the A and X registers can be modified!
                                        (0046) ;               In the large memory model currently only the page
                                        (0047) ;               pointer registers listed below are modified.  This does
                                        (0048) ;               not guarantee that in future implementations of this
                                        (0049) ;               function other page pointer registers will not be
                                        (0050) ;               modified.
                                        (0051) ;          
                                        (0052) ;               Page Pointer Registers Modified: 
                                        (0053) ;               CUR_PP
                                        (0054) ;
                                        (0055) _LoadConfigInit:
                                        (0056)  LoadConfigInit:
                                        (0057)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0058)     
0240: 7C 02 44 LCALL 0x0244             (0059) 	lcall	LoadConfig_pdproject2
                                        (0060) 
                                        (0061) 
                                        (0062)     RAM_EPILOGUE RAM_USE_CLASS_4
0243: 7F       RET                      (0063)     ret
                                        (0064) 
                                        (0065) ;---------------------------------------------------------------------------
                                        (0066) ; Load Configuration pdproject2
                                        (0067) ;
                                        (0068) ;    Load configuration registers for pdproject2.
                                        (0069) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                        (0070) ;
                                        (0071) ;       INPUTS: None.
                                        (0072) ;      RETURNS: Nothing.
                                        (0073) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                        (0074) ;               modified as may the Page Pointer registers!
                                        (0075) ;               In the large memory model currently only the page
                                        (0076) ;               pointer registers listed below are modified.  This does
                                        (0077) ;               not guarantee that in future implementations of this
                                        (0078) ;               function other page pointer registers will not be
                                        (0079) ;               modified.
                                        (0080) ;          
                                        (0081) ;               Page Pointer Registers Modified: 
                                        (0082) ;               CUR_PP
                                        (0083) ;
                                        (0084) _LoadConfig_pdproject2:
                                        (0085)  LoadConfig_pdproject2:
                                        (0086)     RAM_PROLOGUE RAM_USE_CLASS_4
0244: 7C 01 59 LCALL 0x0159             (0087)     lcall   LoadConfigTBL_pdproject2            ; Call load config table routine
0247: 70 EF    AND   F,0xEF             
                                        (0088) 
                                        (0089) 
                                        (0090)     M8C_SetBank0                    ; Force return to bank 0
                                        (0091)     RAM_EPILOGUE RAM_USE_CLASS_4
0249: 7F       RET                      (0092)     ret
                                        (0093) 
                                        (0094) 
                                        (0095) 
                                        (0096) AREA InterruptRAM(ram, rel)
                                        (0097) 
                                        (0098) NO_SHADOW:
                                        (0099) _NO_SHADOW:
FILE: lib\rx8_1int.asm                  (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: RX8_1INT.asm
                                        (0004) ;;   Version: 3.50, Updated on 2014/7/14 at 8:15:1
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "memory.inc"
                                        (0015) include "RX8_1.inc"
                                        (0016) 
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export  _RX8_1_ISR
                                        (0022) 
                                        (0023) 
                                        (0024) IF (RX8_1_RXBUF_ENABLE)
                                        (0025) export  RX8_1_aRxBuffer
                                        (0026) export _RX8_1_aRxBuffer
                                        (0027) export  RX8_1_bRxCnt
                                        (0028) export _RX8_1_bRxCnt
                                        (0029) export  RX8_1_fStatus
                                        (0030) export _RX8_1_fStatus
                                        (0031) ENDIF
                                        (0032) 
                                        (0033) 
                                        (0034) ;-----------------------------------------------
                                        (0035) ; Variable Allocation
                                        (0036) ;-----------------------------------------------
                                        (0037) 
                                        (0038) IF (RX8_1_RXBUF_ENABLE)
                                        (0039) AREA InterruptRAM(RAM,REL,CON)
                                        (0040)  RX8_1_fStatus:
                                        (0041) _RX8_1_fStatus:      BLK  1
                                        (0042)  RX8_1_bRxCnt:
                                        (0043) _RX8_1_bRxCnt:       BLK  1
                                        (0044) AREA RX8_1_RAM(RAM,REL,CON)
                                        (0045)  RX8_1_aRxBuffer:    
                                        (0046) _RX8_1_aRxBuffer:    BLK RX8_1_RX_BUFFER_SIZE
                                        (0047) ENDIF
                                        (0048) 
                                        (0049) 
                                        (0050) AREA InterruptRAM(RAM,REL,CON)
                                        (0051) 
                                        (0052) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0053) ;---------------------------------------------------
                                        (0054) ; Insert your custom declarations below this banner
                                        (0055) ;---------------------------------------------------
                                        (0056) 
                                        (0057) ;------------------------
                                        (0058) ; Includes
                                        (0059) ;------------------------
                                        (0060) 
                                        (0061) 	
                                        (0062) ;------------------------
                                        (0063) ;  Constant Definitions
                                        (0064) ;------------------------
                                        (0065) 
                                        (0066) 
                                        (0067) ;------------------------
                                        (0068) ; Variable Allocation
                                        (0069) ;------------------------
                                        (0070) 
                                        (0071) 
                                        (0072) ;---------------------------------------------------
                                        (0073) ; Insert your custom declarations above this banner
                                        (0074) ;---------------------------------------------------
                                        (0075) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0076) 
                                        (0077) 
                                        (0078) AREA UserModules (ROM, REL)
                                        (0079) 
                                        (0080) ;-----------------------------------------------------------------------------
                                        (0081) ;  FUNCTION NAME: _RX8_1_ISR
                                        (0082) ;
                                        (0083) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0084) ;
                                        (0085) ;-----------------------------------------------------------------------------
                                        (0086) ;
                                        (0087) 
                                        (0088) _RX8_1_ISR:
                                        (0089) 
                                        (0090)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0091)    ;---------------------------------------------------
                                        (0092)    ; Insert your custom assembly code below this banner
                                        (0093)    ;---------------------------------------------------
                                        (0094)    ;   NOTE: interrupt service routines must preserve
                                        (0095)    ;   the values of the A and X CPU registers.
                                        (0096)    
                                        (0097)    ;---------------------------------------------------
                                        (0098)    ; Insert your custom assembly code above this banner
                                        (0099)    ;---------------------------------------------------
                                        (0100)    
                                        (0101)    ;---------------------------------------------------
                                        (0102)    ; Insert a lcall to a C function below this banner
                                        (0103)    ; and un-comment the lines between these banners
                                        (0104)    ;---------------------------------------------------
                                        (0105)    
                                        (0106)    ;PRESERVE_CPU_CONTEXT
024A: 7D 06 8F LJMP  _RX8_1_Interrupt   (0107)    ljmp _RX8_1_Interrupt
                                        (0108)    ;RESTORE_CPU_CONTEXT
                                        (0109)    
                                        (0110)    ;---------------------------------------------------
                                        (0111)    ; Insert a lcall to a C function above this banner
                                        (0112)    ; and un-comment the lines between these banners
                                        (0113)    ;---------------------------------------------------
                                        (0114)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0115) 
                                        (0116)  IF (RX8_1_RXBUF_ENABLE)
                                        (0117)    push A
                                        (0118)    push X
                                        (0119) 
                                        (0120)    IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0121)       REG_PRESERVE IDX_PP                                  ; Save the IDX_PP register	
                                        (0122)    ENDIF
                                        (0123) 
                                        (0124)    mov  X,[RX8_1_bRxCnt]                                   ; Load X with byte counter
                                        (0125)    mov  A,REG[RX8_1_CONTROL_REG]                           ; Read the control register
                                        (0126)    push A                                                  ; Store copy for later test
                                        (0127)                                                            ; IF real RX interrupt
                                        (0128)    and  A,RX8_1_RX_REG_FULL                                ; Did really really get an IRQ
                                        (0129)    jnz  .UARTRX_ReadRx                                     ; Data ready, go get it
                                        (0130)    pop  A                                                  ; Restore stack
                                        (0131)    jmp  .RESTORE_IDX_PP
                                        (0132) 
                                        (0133) .UARTRX_ReadRx:
                                        (0134) 
                                        (0135)    pop  A                                                  ; Restore status flags
                                        (0136)                                                            ; IF there is no error, get data
                                        (0137)                                                            ; Check for parity or framing error
                                        (0138)    and  A,RX8_1_RX_ERROR
                                        (0139)    jz   .UARTRX_NO_ERROR                                   ; If there is not an Error go read data
                                        (0140) 
                                        (0141)    or   [RX8_1_fStatus],A                                  ; Set error flags (parity,framing,overrun) bits
                                        (0142) 
                                        (0143)    tst  REG[RX8_1_RX_BUFFER_REG], 0x00                     ; Read the data buffer to clear it.
                                        (0144) 
                                        (0145)    and  A,RX8_1_RX_FRAMING_ERROR                           ; Check for framing error special case
                                        (0146)    jz   .RESTORE_IDX_PP                                    ; Not framing error, all done
                                        (0147) 
                                        (0148)                                                            ; Disable and re-enable RX to reset after
                                        (0149)                                                            ; framing error.
                                        (0150)    and   REG[RX8_1_CONTROL_REG], ~RX8_1_RX_ENABLE          ; Disable RX
                                        (0151)    or    REG[RX8_1_CONTROL_REG],  RX8_1_RX_ENABLE          ; Enable RX
                                        (0152)    jmp  .RESTORE_IDX_PP                                    ; Done with framing error, leave.
                                        (0153) 
                                        (0154) 
                                        (0155) .UARTRX_NO_ERROR:
                                        (0156)    mov  A,REG[RX8_1_RX_BUFFER_REG ]                        ; Read the data buffer
                                        (0157) 
                                        (0158)                                                            ; IF buffer not full
                                        (0159)    tst  [RX8_1_fStatus],RX8_1_RX_BUF_CMDTERM               ; Check for buffer full
                                        (0160)    jnz  .RESTORE_IDX_PP                                    ; All done
                                        (0161) 
                                        (0162)    cmp  A,RX8_1_CMD_TERM                                   ; Check for End of command
                                        (0163)    jnz  .UARTRX_CHK_CTLCHAR
                                        (0164)    or   [RX8_1_fStatus],RX8_1_RX_BUF_CMDTERM               ; Set command ready bit
                                        (0165) 
                                        (0166)    RAM_SETPAGE_IDX >RX8_1_aRxBuffer
                                        (0167)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
                                        (0168)    mov  [X + RX8_1_aRxBuffer],00h                          ; Zero out last data
                                        (0169)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
                                        (0170)    jmp  .RESTORE_IDX_PP
                                        (0171) 
                                        (0172) .UARTRX_CHK_CTLCHAR:                                       ; Ignore charaters below this value
                                        (0173)                                                            ; If ignore char is set to 0x00, do not
                                        (0174)                                                            ; ignore any characters.
                                        (0175) IF(RX8_1_RX_IGNORE_BELOW)
                                        (0176)    cmp  A,RX8_1_RX_IGNORE_BELOW
                                        (0177)    jc   .RESTORE_IDX_PP
                                        (0178) ENDIF
                                        (0179) 
                                        (0180) .UARTRX_CHK_OVFL:                                          ; Check for MAX String here
                                        (0181)    cmp  [RX8_1_bRxCnt],(RX8_1_RX_BUFFER_SIZE - 1)
                                        (0182)    jc   .UARTRX_ISR_GETDATA
                                        (0183)    or   [RX8_1_fStatus],RX8_1_RX_BUF_OVERRUN               ; Set error flags (parity,framing,overrun) bits
                                        (0184) 
                                        (0185)    RAM_SETPAGE_IDX >RX8_1_aRxBuffer             ;   using idexed address mode
                                        (0186)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
                                        (0187)    mov  [X + RX8_1_aRxBuffer],00h                          ; Zero out last data
                                        (0188)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
                                        (0189)    jmp  .RESTORE_IDX_PP
                                        (0190) 
                                        (0191)                                                            ; IF input data == "CR", then end of command
                                        (0192) .UARTRX_ISR_GETDATA:
                                        (0193)    inc  X                                                  ; Inc the pointer
                                        (0194)    mov  [RX8_1_bRxCnt],X                                   ; Restore the pointer
                                        (0195)    dec  X                                                  ; Mov X to its original value
                                        (0196) 
                                        (0197)    RAM_SETPAGE_IDX >RX8_1_aRxBuffer             ;   using idexed address mode
                                        (0198)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
                                        (0199)    mov  [X+RX8_1_aRxBuffer],A                              ; store data in array
                                        (0200)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
                                        (0201) 
                                        (0202) 
                                        (0203) .RESTORE_IDX_PP:
                                        (0204)    IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0205)       REG_RESTORE IDX_PP
                                        (0206)    ENDIF
                                        (0207) 
                                        (0208) .END_UARTRX_ISR:
                                        (0209)    pop  X
                                        (0210)    pop  A
                                        (0211) 
                                        (0212) ENDIF
                                        (0213) 
                                        (0214) RX8_1_RX_ISR_END:
024D: 7E       RETI                     (0215)    reti
                                        (0216) 
                                        (0217) 
                                        (0218) ; end of file RX8_1INT.asm
FILE: lib\rx8_1.asm                     (0001) ;;*****************************************************************************
024E: 43 E1 04 OR    REG[0xE1],0x4      (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: RX8_1.asm
                                        (0004) ;;   Version: 3.50, Updated on 2014/7/14 at 8:15:1
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: RX8 User Module software implementation file.
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) ;-----------------------------------------------
                                        (0023) ; include instance specific register definitions
                                        (0024) ;-----------------------------------------------
                                        (0025) include "m8c.inc"
                                        (0026) include "memory.inc"
                                        (0027) include "RX8_1.inc"
                                        (0028) 
                                        (0029) 
                                        (0030) ;-----------------------------------------------
                                        (0031) ;  Global Symbols
                                        (0032) ;-----------------------------------------------
                                        (0033) export   RX8_1_EnableInt
                                        (0034) export  _RX8_1_EnableInt
                                        (0035) export   RX8_1_DisableInt
                                        (0036) export  _RX8_1_DisableInt
                                        (0037) export   RX8_1_Start
                                        (0038) export  _RX8_1_Start
                                        (0039) export   RX8_1_Stop
                                        (0040) export  _RX8_1_Stop
                                        (0041) export   RX8_1_bReadRxData
                                        (0042) export  _RX8_1_bReadRxData
                                        (0043) export   RX8_1_bReadRxStatus
                                        (0044) export  _RX8_1_bReadRxStatus
                                        (0045) 
                                        (0046) ; Old function name convension, do not use.
                                        (0047) ; These will be removed in a future release.
                                        (0048) export  bRX8_1_ReadRxData
                                        (0049) export _bRX8_1_ReadRxData
                                        (0050) export  bRX8_1_ReadRxStatus
                                        (0051) export _bRX8_1_ReadRxStatus
                                        (0052) 
                                        (0053) ;-----------------------------------------------
                                        (0054) ; High Level RX functions
                                        (0055) ;-----------------------------------------------
                                        (0056) 
                                        (0057) export  RX8_1_cGetChar
                                        (0058) export _RX8_1_cGetChar
                                        (0059) export  RX8_1_cReadChar
                                        (0060) export _RX8_1_cReadChar
                                        (0061) export  RX8_1_iReadChar
                                        (0062) export _RX8_1_iReadChar
                                        (0063) 
                                        (0064) IF (RX8_1_RXBUF_ENABLE)
                                        (0065) export  RX8_1_CmdReset
                                        (0066) export _RX8_1_CmdReset
                                        (0067) export  RX8_1_bCmdCheck
                                        (0068) export _RX8_1_bCmdCheck
                                        (0069) export  RX8_1_bCmdLength
                                        (0070) export _RX8_1_bCmdLength
                                        (0071) export  RX8_1_bErrCheck
                                        (0072) export _RX8_1_bErrCheck
                                        (0073) 
                                        (0074) export  RX8_1_szGetParam
                                        (0075) export _RX8_1_szGetParam
                                        (0076) export  RX8_1_szGetRestOfParams
                                        (0077) export _RX8_1_szGetRestOfParams
                                        (0078) 
                                        (0079) ;-----------------------------------------------
                                        (0080) ;  Variables
                                        (0081) ;-----------------------------------------------
                                        (0082) 
                                        (0083) AREA RX8_1_RAM(RAM,REL,CON)
                                        (0084)  ptrParam:   			BLK  1
                                        (0085) 
                                        (0086) ENDIF
                                        (0087) ;-----------------------------------------------
                                        (0088) ;  EQUATES
                                        (0089) ;-----------------------------------------------
                                        (0090) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                        (0091) 
                                        (0092) area UserModules (ROM, REL)
                                        (0093) 
                                        (0094) .SECTION
                                        (0095) ;-----------------------------------------------------------------------------
                                        (0096) ;  FUNCTION NAME: RX8_1_EnableInt
                                        (0097) ;
                                        (0098) ;  DESCRIPTION:
                                        (0099) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                        (0100) ;     bit associated with this User Module. Remember to call the global interrupt
                                        (0101) ;     enable function by using the macro: M8C_EnableGInt.
                                        (0102) ;
                                        (0103) ;-----------------------------------------------------------------------------
                                        (0104) ;
                                        (0105) ;  ARGUMENTS: none
                                        (0106) ;
                                        (0107) ;  RETURNS: none
                                        (0108) ;
                                        (0109) ;  SIDE EFFECTS:
                                        (0110) ;    The A and X registers may be modified by this or future implementations
                                        (0111) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0112) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0113) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0114) ;    functions.
                                        (0115) ;
                                        (0116)  RX8_1_EnableInt:
                                        (0117) _RX8_1_EnableInt:
                                        (0118)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0119)    M8C_EnableIntMask RX8_1_INT_REG, RX8_1_bINT_MASK
                                        (0120)    RAM_EPILOGUE RAM_USE_CLASS_1
0251: 7F       RET                      (0121)    ret
                                        (0122) .ENDSECTION
                                        (0123) 
                                        (0124) .SECTION
                                        (0125) ;-----------------------------------------------------------------------------
                                        (0126) ;  FUNCTION NAME: RX8_1_DisableInt
                                        (0127) ;
                                        (0128) ;  DESCRIPTION:
                                        (0129) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                        (0130) ;     associated with this User Module.
                                        (0131) ;
                                        (0132) ;-----------------------------------------------------------------------------
                                        (0133) ;
                                        (0134) ;  ARGUMENTS:  none
                                        (0135) ;
                                        (0136) ;  RETURNS:  none
                                        (0137) ;
                                        (0138) ;  SIDE EFFECTS:
                                        (0139) ;    The A and X registers may be modified by this or future implementations
                                        (0140) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0141) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0142) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0143) ;    functions.
                                        (0144) ;
                                        (0145)  RX8_1_DisableInt:
                                        (0146) _RX8_1_DisableInt:
                                        (0147)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0148)    M8C_DisableIntMask RX8_1_INT_REG, RX8_1_bINT_MASK
                                        (0149)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0150)    ret
                                        (0151) .ENDSECTION
                                        (0152) 
                                        (0153) .SECTION
                                        (0154) ;-----------------------------------------------------------------------------
                                        (0155) ;  FUNCTION NAME: RX8_1_Start(BYTE bParity)
                                        (0156) ;
                                        (0157) ;  DESCRIPTION:
                                        (0158) ;    Sets the start bit and parity in the Control register of this user module.
                                        (0159) ;
                                        (0160) ;-----------------------------------------------------------------------------
                                        (0161) ;
                                        (0162) ;  ARGUMENTS:
                                        (0163) ;    BYTE bParity - parity of received data.  Use defined masks.
                                        (0164) ;    passed in A register.
                                        (0165) ;
                                        (0166) ;  RETURNS: none
                                        (0167) ;
                                        (0168) ;  SIDE EFFECTS:
                                        (0169) ;    The A and X registers may be modified by this or future implementations
                                        (0170) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0171) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0172) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0173) ;    functions.
                                        (0174) ;
                                        (0175)  RX8_1_Start:
                                        (0176) _RX8_1_Start:
                                        (0177)    RAM_PROLOGUE RAM_USE_CLASS_1
0252: 29 01    OR    A,0x1              (0178)    or    A, bfCONTROL_REG_START_BIT
0254: 60 2B    MOV   REG[0x2B],A        (0179)    mov   REG[RX8_1_CONTROL_REG], A
                                        (0180)    RAM_EPILOGUE RAM_USE_CLASS_1
0256: 7F       RET                      (0181)    ret
                                        (0182) .ENDSECTION
                                        (0183) 
                                        (0184) .SECTION
                                        (0185) ;-----------------------------------------------------------------------------
                                        (0186) ;  FUNCTION NAME: RX8_1_Stop
                                        (0187) ;
                                        (0188) ;  DESCRIPTION:
                                        (0189) ;     Disables RX8 operation.
                                        (0190) ;
                                        (0191) ;-----------------------------------------------------------------------------
                                        (0192) ;
                                        (0193) ;  ARGUMENTS: none
                                        (0194) ;
                                        (0195) ;  RETURNS: none
                                        (0196) ;
                                        (0197) ;  SIDE EFFECTS:
                                        (0198) ;    The A and X registers may be modified by this or future implementations
                                        (0199) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0200) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0201) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0202) ;    functions.
                                        (0203) ;
                                        (0204)  RX8_1_Stop:
                                        (0205) _RX8_1_Stop:
                                        (0206)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0207)    and   REG[RX8_1_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                        (0208)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0209)    ret
                                        (0210) .ENDSECTION
                                        (0211) 
                                        (0212) .SECTION
                                        (0213) ;-----------------------------------------------------------------------------
                                        (0214) ;  FUNCTION NAME: RX8_1_bReadRxData
                                        (0215) ;
                                        (0216) ;  DESCRIPTION:
                                        (0217) ;     Reads the RX buffer register.  Should check the status regiser to make
                                        (0218) ;     sure data is valid.
                                        (0219) ;
                                        (0220) ;-----------------------------------------------------------------------------
                                        (0221) ;
                                        (0222) ;  ARGUMENTS:  none
                                        (0223) ;
                                        (0224) ;  RETURNS:
                                        (0225) ;    bRxData - returned in A.
                                        (0226) ;
                                        (0227) ;  SIDE EFFECTS:
                                        (0228) ;    The A and X registers may be modified by this or future implementations
                                        (0229) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0230) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0231) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0232) ;    functions.
                                        (0233) ;
                                        (0234)  RX8_1_bReadRxData:
                                        (0235) _RX8_1_bReadRxData:
                                        (0236)  bRX8_1_ReadRxData:
                                        (0237) _bRX8_1_ReadRxData:
                                        (0238)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0239)    mov A, REG[RX8_1_RX_BUFFER_REG]
                                        (0240)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0241)    ret
                                        (0242) .ENDSECTION
                                        (0243) 
                                        (0244) .SECTION
                                        (0245) ;-----------------------------------------------------------------------------
                                        (0246) ;  FUNCTION NAME: RX8_1_bReadRxStatus
                                        (0247) ;
                                        (0248) ;  DESCRIPTION:
                                        (0249) ;    Reads the RX Status bits in the Control/Status register.
                                        (0250) ;
                                        (0251) ;-----------------------------------------------------------------------------
                                        (0252) ;
                                        (0253) ;  ARGUMENTS:  none
                                        (0254) ;
                                        (0255) ;  RETURNS:
                                        (0256) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                        (0257) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                        (0258) ;
                                        (0259) ;  SIDE EFFECTS:
                                        (0260) ;    The A and X registers may be modified by this or future implementations
                                        (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0264) ;    functions.
                                        (0265) ;
                                        (0266)  RX8_1_bReadRxStatus:
                                        (0267) _RX8_1_bReadRxStatus:
                                        (0268)  bRX8_1_ReadRxStatus:
                                        (0269) _bRX8_1_ReadRxStatus:
                                        (0270)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0271)    mov A,  REG[RX8_1_CONTROL_REG]
                                        (0272)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0273)    ret
                                        (0274) .ENDSECTION
                                        (0275) 
                                        (0276) ;-----------------------------------------------
                                        (0277) ; High Level RX functions
                                        (0278) ;-----------------------------------------------
                                        (0279) 
                                        (0280) .SECTION
                                        (0281) ;-----------------------------------------------------------------------------
                                        (0282) ;  FUNCTION NAME: RX8_1_cGetChar
                                        (0283) ;
                                        (0284) ;  DESCRIPTION:
                                        (0285) ;     Read character from UART RX port.
                                        (0286) ;
                                        (0287) ;
                                        (0288) ;  ARGUMENTS:
                                        (0289) ;      none
                                        (0290) ;
                                        (0291) ;  RETURNS:
                                        (0292) ;     char that is returned from UART
                                        (0293) ;
                                        (0294) ;  SIDE EFFECTS:
                                        (0295) ;    The A and X registers may be modified by this or future implementations
                                        (0296) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0297) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0298) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0299) ;    functions.
                                        (0300) ;    
                                        (0301) ;    Program flow will stay in this function until a character is received.
                                        (0302) ;    If the watchdog timer is used, care must be taken to make sure that
                                        (0303) ;    the delay between characters is less than the watchdog timeout.
                                        (0304) ;
                                        (0305)  RX8_1_cGetChar:
                                        (0306) _RX8_1_cGetChar:
                                        (0307)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0308) 
                                        (0309) .getChar_Loop:
0257: 49 2B 08 TST   REG[0x2B],0x8      (0310)    tst REG[RX8_1_CONTROL_REG],RX8_1_RX_REG_FULL  ; Check if a character is ready
025A: AF FC    JZ    RX8_1_cGetChar|_RX8_1_bReadRxData|_bRX8_1_ReadRxData|_RX8_1_Stop|_bRX8_1_ReadRxStatus|_RX8_1_bReadRxStatus|bRX8_1_ReadRxStatus|bRX8_1_ReadRxData|_RX8_1_cGetChar(0311)    jz  .getChar_Loop                                        ; If not loop
                                        (0312) 
025C: 5D 2A    MOV   A,REG[0x2A]        (0313)    mov A, REG[RX8_1_RX_BUFFER_REG]               ; Get character
                                        (0314)    RAM_EPILOGUE RAM_USE_CLASS_1
025E: 7F       RET                      (0315)    ret
                                        (0316) .ENDSECTION
                                        (0317) 
                                        (0318) .SECTION
                                        (0319) ;-----------------------------------------------------------------------------
                                        (0320) ;  FUNCTION NAME: RX8_1_cReadChar
                                        (0321) ;
                                        (0322) ;  DESCRIPTION:
                                        (0323) ;     Read character from UART RX port.
                                        (0324) ;
                                        (0325) ;  ARGUMENTS:
                                        (0326) ;      none
                                        (0327) ;
                                        (0328) ;  RETURNS:
                                        (0329) ;     char that is returned from UART
                                        (0330) ;
                                        (0331) ;  SIDE EFFECTS:
                                        (0332) ;    The A and X registers may be modified by this or future implementations
                                        (0333) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0334) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0335) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0336) ;    functions.
                                        (0337) ;
                                        (0338) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                        (0339) ;    implies a valid character or an error condition occured.
                                        (0340) ;
                                        (0341)  RX8_1_cReadChar:
                                        (0342) _RX8_1_cReadChar:
                                        (0343)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0344) 
                                        (0345)    mov  A,REG[RX8_1_CONTROL_REG]                           ; Get Status of RX
                                        (0346)    push A
                                        (0347)    and  A,RX8_1_RX_COMPLETE                                ; Check if a character is ready
                                        (0348)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
                                        (0349)    pop  A
                                        (0350)    jmp  .RX_NO_VALID_CHAR
                                        (0351) 
                                        (0352) .RX_DATA_RDY:
                                        (0353)    mov  A,REG[RX8_1_RX_BUFFER_REG]                         ; Read data first, then
                                        (0354)    swap A,X                                                ; determine if data is valid
                                        (0355) 
                                        (0356)    pop  A                                                  ; Check for errors
                                        (0357)    and  A,(RX8_1_RX_PARITY_ERROR | RX8_1_RX_FRAMING_ERROR)
                                        (0358)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                        (0359)    swap A,X                                                ; Put data in A and exit
                                        (0360)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0361)    ret
                                        (0362) 
                                        (0363) .RX_NO_VALID_CHAR:
                                        (0364)    mov A,0x00                                              ; Zero out character
                                        (0365) 
                                        (0366)  End_RX8_1_cReadChar:
                                        (0367)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0368)    ret
                                        (0369) .ENDSECTION
                                        (0370) 																			
                                        (0371) .SECTION
                                        (0372) ;-----------------------------------------------------------------------------
                                        (0373) ;  FUNCTION NAME: RX8_1_iReadChar
                                        (0374) ;
                                        (0375) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                        (0376) ; to just set a value in the upper byte if error conditions exists.
                                        (0377) ;
                                        (0378) ;  DESCRIPTION:
                                        (0379) ;     Read character from UART RX port.
                                        (0380) ;
                                        (0381) ;  ARGUMENTS:
                                        (0382) ;      none
                                        (0383) ;
                                        (0384) ;  RETURNS:
                                        (0385) ;     An integer value is returned.  A negative value inplies and error
                                        (0386) ;     condition, a positive value between 0 and 255 is the return character.
                                        (0387) ;
                                        (0388) ;     Error Codes:
                                        (0389) ;        0x80CC    Parity Error
                                        (0390) ;        0x40CC    Overrun Error
                                        (0391) ;        0x20CC    Framing Error
                                        (0392) ;        0x01CC    No Data available
                                        (0393) ;
                                        (0394) ;  SIDE EFFECTS:
                                        (0395) ;    The A and X registers may be modified by this or future implementations
                                        (0396) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0397) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0398) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0399) ;    functions.
                                        (0400) ;
                                        (0401)  RX8_1_iReadChar:
                                        (0402) _RX8_1_iReadChar:
                                        (0403)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0404) 
                                        (0405)    mov  A,REG[RX8_1_CONTROL_REG]                           ; Get Status of RX
                                        (0406)                                                            ; Mask only errors and data ready
                                        (0407)    and  A,(RX8_1_RX_ERROR|RX8_1_RX_REG_FULL)
                                        (0408)    push A
                                        (0409)    and  A,RX8_1_RX_COMPLETE                                ; Check if a character is ready
                                        (0410)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                        (0411)    pop  A
                                        (0412)    or   A,RX8_1_RX_NO_DATA                                 ; Add no data flag
                                        (0413)    swap A,X
                                        (0414)    jmp  End_RX8_1_iReadChar
                                        (0415) 
                                        (0416) .RX_GET_DATA:
                                        (0417)    pop  A
                                        (0418)    and  A,RX8_1_RX_ERROR
                                        (0419)    swap A,X
                                        (0420)    mov  A,REG[RX8_1_RX_BUFFER_REG]                         ; Read data first, then
                                        (0421)                                                            ; determine if data is valid
                                        (0422) 
                                        (0423)  End_RX8_1_iReadChar:
                                        (0424)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0425)    ret
                                        (0426) .ENDSECTION
                                        (0427) 
                                        (0428) 
                                        (0429) 
                                        (0430) IF (RX8_1_RXBUF_ENABLE)
                                        (0431) .SECTION
                                        (0432) ;-----------------------------------------------------------------------------
                                        (0433) ;-----------------------------------------------------------------------------
                                        (0434) ;
                                        (0435) ;     Command Buffer commands
                                        (0436) ;
                                        (0437) ;-----------------------------------------------------------------------------
                                        (0438) ;-----------------------------------------------------------------------------
                                        (0439) 
                                        (0440) ;-----------------------------------------------------------------------------
                                        (0441) ;  FUNCTION NAME: RX8_1_CmdReset
                                        (0442) ;
                                        (0443) ;  DESCRIPTION:
                                        (0444) ;     Reset command string and status flags
                                        (0445) ;
                                        (0446) ;  ARGUMENTS:
                                        (0447) ;     none.
                                        (0448) ;
                                        (0449) ;  RETURNS:
                                        (0450) ;     none.
                                        (0451) ;
                                        (0452) ;  SIDE EFFECTS:
                                        (0453) ;    The A and X registers may be modified by this or future implementations
                                        (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0457) ;    functions.
                                        (0458) ;          
                                        (0459) ;    Currently only the page pointer registers listed below are modified: 
                                        (0460) ;          CUR_PP
                                        (0461) ;
                                        (0462) ;  THEORY of OPERATION or PROCEDURE:
                                        (0463) ;     Clear the command buffer, command counter, and flag.
                                        (0464) ;
                                        (0465)  RX8_1_CmdReset:
                                        (0466) _RX8_1_CmdReset:
                                        (0467)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0468)    RAM_SETPAGE_CUR >RX8_1_aRxBuffer
                                        (0469)    mov [RX8_1_aRxBuffer], 0x00
                                        (0470)    RAM_SETPAGE_CUR >ptrParam
                                        (0471)    mov [ptrParam],0x00
                                        (0472)    RAM_SETPAGE_CUR >RX8_1_bRxCnt
                                        (0473)    mov [RX8_1_bRxCnt], 0x00
                                        (0474)    and [RX8_1_fStatus], 0x00
                                        (0475)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0476)    ret
                                        (0477) .ENDSECTION
                                        (0478) 
                                        (0479) .SECTION
                                        (0480) ;-----------------------------------------------------------------------------
                                        (0481) ;  FUNCTION NAME: RX8_1_bCmdCheck
                                        (0482) ;
                                        (0483) ;  DESCRIPTION:
                                        (0484) ;     Check to see if valid command in buffer.
                                        (0485) ;
                                        (0486) ;  ARGUMENTS:
                                        (0487) ;     none.
                                        (0488) ;
                                        (0489) ;  RETURNS:
                                        (0490) ;     BYTE  fStatus - Status of command receive buffer.
                                        (0491) ;                     Returns non-zero value in A if command is valid.
                                        (0492) ;
                                        (0493) ;  SIDE EFFECTS:
                                        (0494) ;    The A and X registers may be modified by this or future implementations
                                        (0495) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0496) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0497) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0498) ;    functions.
                                        (0499) ;          
                                        (0500) ;    Currently only the page pointer registers listed below are modified: 
                                        (0501) ;          CUR_PP
                                        (0502) ;
                                        (0503) ;  THEORY of OPERATION or PROCEDURE:
                                        (0504) ;     Read the status and control register.
                                        (0505) ;
                                        (0506)  RX8_1_bCmdCheck:
                                        (0507) _RX8_1_bCmdCheck:
                                        (0508)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0509)    RAM_SETPAGE_CUR >RX8_1_fStatus
                                        (0510)    mov A,  [RX8_1_fStatus]
                                        (0511)    and A, RX8_1_RX_BUF_CMDTERM                   ; Mask off Command status
                                        (0512)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0513)    ret
                                        (0514) .ENDSECTION
                                        (0515) 
                                        (0516) .SECTION
                                        (0517) ;-----------------------------------------------------------------------------
                                        (0518) ;  FUNCTION NAME: RX8_1_bErrCheck
                                        (0519) ;
                                        (0520) ;  DESCRIPTION:
                                        (0521) ;     Check to see if an error has occured since last CmdReset
                                        (0522) ;
                                        (0523) ;  ARGUMENTS:
                                        (0524) ;     none.
                                        (0525) ;
                                        (0526) ;  RETURNS:
                                        (0527) ;     BYTE  fStatus - Status of command receive buffer.
                                        (0528) ;                     Returns non-zero value in A if command is valid.
                                        (0529) ;           0x80 => Parity Error
                                        (0530) ;           0x40 => OverRun Error
                                        (0531) ;           0x20 => Framing Error
                                        (0532) ;           0x10 => Software Buffer OverRun
                                        (0533) ;
                                        (0534) ;  SIDE EFFECTS:
                                        (0535) ;    The A and X registers may be modified by this or future implementations
                                        (0536) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0537) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0538) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0539) ;    functions.
                                        (0540) ;          
                                        (0541) ;    Currently only the page pointer registers listed below are modified: 
                                        (0542) ;          CUR_PP
                                        (0543) ;
                                        (0544) ;     Error Status is clear when read.
                                        (0545) ;
                                        (0546) ;  THEORY of OPERATION or PROCEDURE:
                                        (0547) ;     Read RX buffer error status and clear status
                                        (0548) ;
                                        (0549)  RX8_1_bErrCheck:
                                        (0550) _RX8_1_bErrCheck:
                                        (0551)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0552)    RAM_SETPAGE_CUR >RX8_1_fStatus
                                        (0553)    mov A,  [RX8_1_fStatus]
                                        (0554)    and A, RX8_1_RX_BUF_ERROR                     ; Mask off Error status
                                        (0555)    and [RX8_1_fStatus], ~RX8_1_RX_BUF_ERROR
                                        (0556)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0557)    ret
                                        (0558) .ENDSECTION
                                        (0559) 
                                        (0560) .SECTION
                                        (0561) ;-----------------------------------------------------------------------------
                                        (0562) ;  FUNCTION NAME: RX8_1_bCmdLength
                                        (0563) ;
                                        (0564) ;  DESCRIPTION:
                                        (0565) ;     Get length of command string
                                        (0566) ;
                                        (0567) ;  ARGUMENTS:
                                        (0568) ;     none.
                                        (0569) ;
                                        (0570) ;  RETURNS:
                                        (0571) ;     BYTE  bRxCnt    Returns the command length in A.
                                        (0572) ;
                                        (0573) ;  SIDE EFFECTS:
                                        (0574) ;    The A and X registers may be modified by this or future implementations
                                        (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0578) ;    functions.
                                        (0579) ;          
                                        (0580) ;    Currently only the page pointer registers listed below are modified: 
                                        (0581) ;          CUR_PP
                                        (0582) ;
                                        (0583)  RX8_1_bCmdLength:
                                        (0584) _RX8_1_bCmdLength:
                                        (0585)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0586)    RAM_SETPAGE_CUR >RX8_1_bRxCnt
                                        (0587)    mov A,  [RX8_1_bRxCnt]
                                        (0588)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0589)    ret
                                        (0590) .ENDSECTION
                                        (0591) 
                                        (0592) .SECTION
                                        (0593) ;-----------------------------------------------------------------------------
                                        (0594) ;  FUNCTION NAME: RX8_1_szGetParam
                                        (0595) ;
                                        (0596) ;  DESCRIPTION:
                                        (0597) ;      Return next parameter from UART Rx buffer
                                        (0598) ;
                                        (0599) ;
                                        (0600) ;  ARGUMENTS:  none
                                        (0601) ;
                                        (0602) ;  RETURNS:
                                        (0603) ;     A => MSB of parameter address
                                        (0604) ;     X => LSB of parameter address
                                        (0605) ;
                                        (0606) ;  SIDE EFFECTS:
                                        (0607) ;    The A and X registers may be modified by this or future implementations
                                        (0608) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0609) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0610) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0611) ;    functions.
                                        (0612) ;          
                                        (0613) ;    Currently only the page pointer registers listed below are modified:
                                        (0614) ;          CUR_PP
                                        (0615) ;          IDX_PP
                                        (0616) ;
                                        (0617) ;     The receive string is modified by placing Null characters at the end
                                        (0618) ;     of each parameter as they are recovered.
                                        (0619) ;
                                        (0620) ;  THEORY OF OPERATION:
                                        (0621) ;     This function is a stateful generator of addresses to the "parameters"
                                        (0622) ;     of an input "Command". It scans the (optional) input buffer and breaks
                                        (0623) ;     each lexically distinct element into a null-terminated string by replacing
                                        (0624) ;     delimiters with nulls, as appropriate. The state of the generator is 
                                        (0625) ;     maintained by the private variable ptrParam, which is a buffer-relative
                                        (0626) ;     offset. The generator is initialized by a call to the function
                                        (0627) ;     RX8_1_CmdReset which resets the entire buffer to the 'empty'
                                        (0628) ;     state. Typically this function, RX8_1_szGetParam, is
                                        (0629) ;     not called until the buffer has been loaded with an entire command
                                        (0630) ;     (See RX8_1_bCmdCheck).
                                        (0631) ;
                                        (0632) ;     Note, there is no special distinction between the "command" and the 
                                        (0633) ;     "parameters". The first non-delimiter character of the buffer---the first
                                        (0634) ;     character of the "command"---is also, for the purposes of this function,
                                        (0635) ;     the first "parameter" to which it returns an address.
                                        (0636) ;
                                        (0637) ;     The value of a delimiter (commonly an ascii space, 0x20 and decimal 32)
                                        (0638) ;     is determined at configuration time by a user module parameter.
                                        (0639) ;
                                        (0640)  RX8_1_szGetParam:
                                        (0641) _RX8_1_szGetParam:
                                        (0642)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0643)    RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0644)    RAM_SETPAGE_CUR >ptrParam
                                        (0645)    RAM_SETPAGE_IDX >RX8_1_aRxBuffer
                                        (0646) 
                                        (0647)    mov  A, <RX8_1_aRxBuffer                 ; Get address to receive buffer
                                        (0648)    add  A, [ptrParam]                      ; Add string offset
                                        (0649)    mov  X,A
                                        (0650) 
                                        (0651)    mov  A,[X]                              ; Get character pointed by X
                                        (0652)    jnz  .CheckForDelim                     ; Check for Null character
                                        (0653)    push X                                  ; Save LSB of current pointer
                                        (0654)    jmp  .End_GetNextParam
                                        (0655) 
                                        (0656)                                             ; Check for delimiter and keep looping until
                                        (0657)                                             ; all leading delimiters have been found.
                                        (0658) .CheckForDelim:
                                        (0659)     cmp  A,RX8_1_DELIMITER                  ; Check if we have a delimiter
                                        (0660)     jnz  .ParamStartFound
                                        (0661)     inc  X                                  ; Increment both current pointer and
                                        (0662)     inc  [ptrParam]                         ; stored pointer.
                                        (0663)     mov  A,[X]                              ; Get character pointed by X
                                        (0664)     cmp  [ptrParam],(RX8_1_RX_BUFFER_SIZE -1)  ; Check if we are at the end of buffer
                                        (0665)     jnz  .CheckForDelim
                                        (0666)                                             ; End of string found
                                        (0667) .EndOfString:
                                        (0668)     push X                                  ; Save ptr
                                        (0669) .TerminateString:
                                        (0670)     mov  [X],0x00                           ; Make sure string is zero
                                        (0671)     jmp  .End_GetNextParam
                                        (0672) 
                                        (0673) .ParamStartFound:
                                        (0674)     push X                                  ; Beginning of parameter found, save pointer
                                        (0675) 
                                        (0676) .ParamLoop:
                                        (0677)                                             ; Now loop until end of parameter found.
                                        (0678)     inc  X                                  ; Advance pointers.
                                        (0679)     inc  [ptrParam]
                                        (0680)     cmp  [ptrParam],(RX8_1_RX_BUFFER_SIZE -1)  ; Check if we are at the end of buffer
                                        (0681)     jz   .TerminateString
                                        (0682)     mov  A,[X]                              ; Get next character
                                        (0683)     jz   .End_GetNextParam
                                        (0684)     cmp  A,RX8_1_DELIMITER                  ; Check if we have a delimiter
                                        (0685)     jnz  .ParamLoop                         ; Still no delimiter, loop again
                                        (0686) 
                                        (0687)     mov  [X],0x00                           ; Replace delimiter with null for end of substring
                                        (0688)     inc  [ptrParam]
                                        (0689)     cmp  [ptrParam],(RX8_1_RX_BUFFER_SIZE -1)  ; Check if we are at the end of buffer
                                        (0690)     jnz  .End_GetNextParam                  ; If not end of string leave
                                        (0691)     mov  [ptrParam],(RX8_1_RX_BUFFER_SIZE -1)  ; Reset pointer to end of string.
                                        (0692) 
                                        (0693) 
                                        (0694) .End_GetNextParam:
                                        (0695)    pop  X
                                        (0696)    push X
                                        (0697)    cmp  [X],0x00
                                        (0698)    jnz  .NotNullString
                                        (0699)    pop  X
                                        (0700)    mov  X,0x00
                                        (0701)    mov  A,X
                                        (0702)    RAM_EPILOGUE RAM_USE_CLASS_3
                                        (0703)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0704)    ret
                                        (0705) 
                                        (0706) .NotNullString:
                                        (0707)    pop  X
                                        (0708)    mov  A,>RX8_1_aRxBuffer                     ; Return pointer
                                        (0709)    RAM_EPILOGUE RAM_USE_CLASS_3
                                        (0710)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0711)    ret
                                        (0712) .ENDSECTION
                                        (0713) 
                                        (0714) .SECTION
                                        (0715) ;-----------------------------------------------------------------------------
                                        (0716) ;  FUNCTION NAME: RX8_1_szGetRestOfParams
                                        (0717) ;
                                        (0718) ;  DESCRIPTION:
                                        (0719) ;      Return the rest of the UART RX buffer
                                        (0720) ;
                                        (0721) ;
                                        (0722) ;  ARGUMENTS:  none
                                        (0723) ;
                                        (0724) ;  RETURNS:
                                        (0725) ;     A => MSB of parameter
                                        (0726) ;     X => LSB of parameter
                                        (0727) ;
                                        (0728) ;  SIDE EFFECTS:
                                        (0729) ;    The A and X registers may be modified by this or future implementations
                                        (0730) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0731) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0732) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0733) ;    functions.
                                        (0734) ;          
                                        (0735) ;    Currently only the page pointer registers listed below are modified: 
                                        (0736) ;          CUR_PP
                                        (0737) ;
                                        (0738)  RX8_1_szGetRestOfParams:
                                        (0739) _RX8_1_szGetRestOfParams:
                                        (0740)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0741)    RAM_SETPAGE_CUR >ptrParam
                                        (0742) 
                                        (0743)     mov  A, <RX8_1_aRxBuffer                ; Get address to receive buffer
                                        (0744)     add  A, [ptrParam]                      ; Add string offset
                                        (0745)     mov  X,A
                                        (0746)     mov  A,>RX8_1_aRxBuffer                 ; Return pointer
                                        (0747) 
                                        (0748)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0749)     ret
                                        (0750) .ENDSECTION
                                        (0751) 
                                        (0752) ENDIF
                                        (0753) ; End of File RX8_1.asm
FILE: lib\pwm16_1int.asm                (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: PWM16_1INT.asm
                                        (0004) ;;   Version: 2.5, Updated on 2014/7/14 at 8:14:50
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: PWM16 Interrupt Service Routine
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "PWM16_1.inc"
                                        (0015) include "memory.inc"
                                        (0016) 
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export  _PWM16_1_ISR
                                        (0022) 
                                        (0023) 
                                        (0024) AREA InterruptRAM (RAM,REL,CON)
                                        (0025) 
                                        (0026) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0027) ;---------------------------------------------------
                                        (0028) ; Insert your custom declarations below this banner
                                        (0029) ;---------------------------------------------------
                                        (0030) 
                                        (0031) ;------------------------
                                        (0032) ; Includes
                                        (0033) ;------------------------
                                        (0034) 
                                        (0035) 	
                                        (0036) ;------------------------
                                        (0037) ;  Constant Definitions
                                        (0038) ;------------------------
                                        (0039) 
                                        (0040) 
                                        (0041) ;------------------------
                                        (0042) ; Variable Allocation
                                        (0043) ;------------------------
                                        (0044) 
                                        (0045) 
                                        (0046) ;---------------------------------------------------
                                        (0047) ; Insert your custom declarations above this banner
                                        (0048) ;---------------------------------------------------
                                        (0049) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0050) 
                                        (0051) 
                                        (0052) AREA UserModules (ROM, REL)
                                        (0053) 
                                        (0054) ;-----------------------------------------------------------------------------
                                        (0055) ;  FUNCTION NAME: _PWM16_1_ISR
                                        (0056) ;
                                        (0057) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0058) ;
                                        (0059) ;-----------------------------------------------------------------------------
                                        (0060) ;
                                        (0061) 
                                        (0062) _PWM16_1_ISR:
                                        (0063) 
                                        (0064)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0065)    ;---------------------------------------------------
                                        (0066)    ; Insert your custom assembly code below this banner
                                        (0067)    ;---------------------------------------------------
                                        (0068)    ;   NOTE: interrupt service routines must preserve
                                        (0069)    ;   the values of the A and X CPU registers.
                                        (0070)    
                                        (0071)    ;---------------------------------------------------
                                        (0072)    ; Insert your custom assembly code above this banner
                                        (0073)    ;---------------------------------------------------
                                        (0074)    
                                        (0075)    ;---------------------------------------------------
                                        (0076)    ; Insert a lcall to a C function below this banner
                                        (0077)    ; and un-comment the lines between these banners
                                        (0078)    ;---------------------------------------------------
                                        (0079)    
                                        (0080)    ;PRESERVE_CPU_CONTEXT
025F: 7D 05 52 LJMP  _PWM16_1_CMP_ISR   (0081)    ljmp _PWM16_1_CMP_ISR
                                        (0082)    ;RESTORE_CPU_CONTEXT
                                        (0083)    
                                        (0084)    ;---------------------------------------------------
                                        (0085)    ; Insert a lcall to a C function above this banner
                                        (0086)    ; and un-comment the lines between these banners
                                        (0087)    ;---------------------------------------------------
                                        (0088)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0089) 
0262: 7E       RETI                     (0090)    reti
                                        (0091) 
                                        (0092) 
                                        (0093) ; end of file PWM16_1INT.asm
FILE: lib\pwm16_1.asm                   (0001) ;;*****************************************************************************
0263: 43 E1 02 OR    REG[0xE1],0x2      (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: PWM16_1.asm
                                        (0004) ;;   Version: 2.5, Updated on 2014/7/14 at 8:14:50
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: PWM16 User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "PWM16_1.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export  PWM16_1_EnableInt
                                        (0030) export _PWM16_1_EnableInt
                                        (0031) export  PWM16_1_DisableInt
                                        (0032) export _PWM16_1_DisableInt
                                        (0033) export  PWM16_1_Start
                                        (0034) export _PWM16_1_Start
                                        (0035) export  PWM16_1_Stop
                                        (0036) export _PWM16_1_Stop
                                        (0037) export  PWM16_1_WritePeriod
                                        (0038) export _PWM16_1_WritePeriod
                                        (0039) export  PWM16_1_WritePulseWidth
                                        (0040) export _PWM16_1_WritePulseWidth
                                        (0041) export  PWM16_1_wReadPulseWidth
                                        (0042) export _PWM16_1_wReadPulseWidth
                                        (0043) export  PWM16_1_wReadCounter
                                        (0044) export _PWM16_1_wReadCounter
                                        (0045) 
                                        (0046) ; The following functions are deprecated and subject to omission in future releases
                                        (0047) ;
                                        (0048) export  wPWM16_1_ReadPulseWidth    ; deprecated
                                        (0049) export _wPWM16_1_ReadPulseWidth    ; deprecated
                                        (0050) export  wPWM16_1_ReadCounter       ; deprecated
                                        (0051) export _wPWM16_1_ReadCounter       ; deprecated
                                        (0052) 
                                        (0053) 
                                        (0054) AREA pdproject2_RAM (RAM,REL)
                                        (0055) 
                                        (0056) ;-----------------------------------------------
                                        (0057) ;  Constant Definitions
                                        (0058) ;-----------------------------------------------
                                        (0059) 
                                        (0060) INPUT_REG_NULL:                equ 0x00    ; Clear the input register
                                        (0061) 
                                        (0062) 
                                        (0063) ;-----------------------------------------------
                                        (0064) ; Variable Allocation
                                        (0065) ;-----------------------------------------------
                                        (0066) 
                                        (0067) 
                                        (0068) AREA UserModules (ROM, REL)
                                        (0069) 
                                        (0070) .SECTION
                                        (0071) ;-----------------------------------------------------------------------------
                                        (0072) ;  FUNCTION NAME: PWM16_1_EnableInt
                                        (0073) ;
                                        (0074) ;  DESCRIPTION:
                                        (0075) ;     Enables this PWM's interrupt by setting the interrupt enable mask bit
                                        (0076) ;     associated with this User Module. This function has no effect until and
                                        (0077) ;     unless the global interrupts are enabled (for example by using the
                                        (0078) ;     macro M8C_EnableGInt).
                                        (0079) ;-----------------------------------------------------------------------------
                                        (0080) ;
                                        (0081) ;  ARGUMENTS:    None.
                                        (0082) ;  RETURNS:      Nothing.
                                        (0083) ;  SIDE EFFECTS: 
                                        (0084) ;    The A and X registers may be modified by this or future implementations
                                        (0085) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0086) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0087) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0088) ;    functions.
                                        (0089) ;
                                        (0090)  PWM16_1_EnableInt:
                                        (0091) _PWM16_1_EnableInt:
                                        (0092)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0093)    PWM16_1_EnableInt_M
                                        (0094)    RAM_EPILOGUE RAM_USE_CLASS_1
0266: 7F       RET                      (0095)    ret
0267: 43 23 01 OR    REG[0x23],0x1      
                                        (0096) 
                                        (0097) 
                                        (0098) .ENDSECTION
                                        (0099) 
                                        (0100) .SECTION
                                        (0101) ;-----------------------------------------------------------------------------
                                        (0102) ;  FUNCTION NAME: PWM16_1_DisableInt
                                        (0103) ;
                                        (0104) ;  DESCRIPTION:
                                        (0105) ;     Disables this PWM's interrupt by clearing the interrupt enable
                                        (0106) ;     mask bit associated with this User Module.
                                        (0107) ;-----------------------------------------------------------------------------
                                        (0108) ;
                                        (0109) ;  ARGUMENTS:    None
                                        (0110) ;  RETURNS:      Nothing
                                        (0111) ;  SIDE EFFECTS:
                                        (0112) ;    The A and X registers may be modified by this or future implementations
                                        (0113) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0114) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0115) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0116) ;    functions.
                                        (0117) ;
                                        (0118)  PWM16_1_DisableInt:
                                        (0119) _PWM16_1_DisableInt:
                                        (0120)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0121)    PWM16_1_DisableInt_M
                                        (0122)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0123)    ret
                                        (0124) 
                                        (0125) 
                                        (0126) .ENDSECTION
                                        (0127) 
                                        (0128) .SECTION
                                        (0129) ;-----------------------------------------------------------------------------
                                        (0130) ;  FUNCTION NAME: PWM16_1_Start
                                        (0131) ;
                                        (0132) ;  DESCRIPTION:
                                        (0133) ;     Sets the start bit in the Control register of this user module.  The
                                        (0134) ;     PWM will begin counting on the next input clock as soon as the
                                        (0135) ;     enable input is asserted high.
                                        (0136) ;-----------------------------------------------------------------------------
                                        (0137) ;
                                        (0138) ;  ARGUMENTS:    None
                                        (0139) ;  RETURNS:      Nothing
                                        (0140) ;  SIDE EFFECTS:
                                        (0141) ;    The A and X registers may be modified by this or future implementations
                                        (0142) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0143) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0144) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0145) ;    functions.
                                        (0146) ;
                                        (0147)  PWM16_1_Start:
                                        (0148) _PWM16_1_Start:
                                        (0149)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0150)    PWM16_1_Start_M
                                        (0151)    RAM_EPILOGUE RAM_USE_CLASS_1
026A: 7F       RET                      (0152)    ret
                                        (0153) 
                                        (0154) 
                                        (0155) .ENDSECTION
                                        (0156) 
                                        (0157) .SECTION
                                        (0158) ;-----------------------------------------------------------------------------
                                        (0159) ;  FUNCTION NAME: PWM16_1_Stop
                                        (0160) ;
                                        (0161) ;  DESCRIPTION:
                                        (0162) ;     Disables PWM operation by clearing the start bit in the Control
                                        (0163) ;     register of the LSB block.
                                        (0164) ;-----------------------------------------------------------------------------
                                        (0165) ;
                                        (0166) ;  ARGUMENTS:    None
                                        (0167) ;  RETURNS:      Nothing
                                        (0168) ;  SIDE EFFECTS:
                                        (0169) ;    The A and X registers may be modified by this or future implementations
                                        (0170) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0171) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0172) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0173) ;    functions.
                                        (0174) ;
                                        (0175)  PWM16_1_Stop:
                                        (0176) _PWM16_1_Stop:
                                        (0177)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0178)    PWM16_1_Stop_M
                                        (0179)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0180)    ret
                                        (0181) 
                                        (0182) 
                                        (0183) .ENDSECTION
                                        (0184) 
                                        (0185) .SECTION
                                        (0186) ;-----------------------------------------------------------------------------
                                        (0187) ;  FUNCTION NAME: PWM16_1_WritePeriod
                                        (0188) ;
                                        (0189) ;  DESCRIPTION:
                                        (0190) ;     Write the 16-bit period value into the Period register (DR1).
                                        (0191) ;-----------------------------------------------------------------------------
                                        (0192) ;
                                        (0193) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                        (0194) ;  RETURNS:   Nothing
                                        (0195) ;  SIDE EFFECTS:
                                        (0196) ;    If the PWM user module is stopped, then this value will also be
                                        (0197) ;    latched into the Count registers (DR0).
                                        (0198) ;    
                                        (0199) ;    The A and X registers may be modified by this or future implementations
                                        (0200) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0201) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0202) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0203) ;    functions.
                                        (0204) ;
                                        (0205)  PWM16_1_WritePeriod:
                                        (0206) _PWM16_1_WritePeriod:
                                        (0207)    RAM_PROLOGUE RAM_USE_CLASS_1
026B: 60 21    MOV   REG[0x21],A        (0208)    mov   reg[PWM16_1_PERIOD_LSB_REG], A
026D: 5B       MOV   A,X                (0209)    mov   A, X
026E: 60 25    MOV   REG[0x25],A        (0210)    mov   reg[PWM16_1_PERIOD_MSB_REG], A
                                        (0211)    RAM_EPILOGUE RAM_USE_CLASS_1
0270: 7F       RET                      (0212)    ret
                                        (0213) 
                                        (0214) 
                                        (0215) .ENDSECTION
                                        (0216) 
                                        (0217) .SECTION
                                        (0218) ;-----------------------------------------------------------------------------
                                        (0219) ;  FUNCTION NAME: PWM16_1_WritePulseWidth
                                        (0220) ;
                                        (0221) ;  DESCRIPTION:
                                        (0222) ;     Writes the pulse width value into the Compare register (DR2).
                                        (0223) ;-----------------------------------------------------------------------------
                                        (0224) ;
                                        (0225) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
                                        (0226) ;  RETURNS:      Nothing
                                        (0227) ;  SIDE EFFECTS:
                                        (0228) ;    The A and X registers may be modified by this or future implementations
                                        (0229) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0230) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0231) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0232) ;    functions.
                                        (0233) ;
                                        (0234)  PWM16_1_WritePulseWidth:
                                        (0235) _PWM16_1_WritePulseWidth:
                                        (0236)    RAM_PROLOGUE RAM_USE_CLASS_1
0271: 60 22    MOV   REG[0x22],A        (0237)    mov   reg[PWM16_1_COMPARE_LSB_REG], A
0273: 5B       MOV   A,X                (0238)    mov   A, X
0274: 60 26    MOV   REG[0x26],A        (0239)    mov   reg[PWM16_1_COMPARE_MSB_REG], A
                                        (0240)    RAM_EPILOGUE RAM_USE_CLASS_1
0276: 7F       RET                      (0241)    ret
                                        (0242) 
                                        (0243) 
                                        (0244) .ENDSECTION
                                        (0245) 
                                        (0246) .SECTION
                                        (0247) ;-----------------------------------------------------------------------------
                                        (0248) ;  FUNCTION NAME: PWM16_1_wReadPulseWidth
                                        (0249) ;
                                        (0250) ;  DESCRIPTION:
                                        (0251) ;     Reads the Compare register.
                                        (0252) ;-----------------------------------------------------------------------------
                                        (0253) ;
                                        (0254) ;  ARGUMENTS:    None
                                        (0255) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                        (0256) ;  SIDE EFFECTS:
                                        (0257) ;    The A and X registers may be modified by this or future implementations
                                        (0258) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0259) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0260) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0261) ;    functions.
                                        (0262) ;
                                        (0263)  PWM16_1_wReadPulseWidth:
                                        (0264) _PWM16_1_wReadPulseWidth:
                                        (0265)  wPWM16_1_ReadPulseWidth:                        ; this name deprecated
                                        (0266) _wPWM16_1_ReadPulseWidth:                        ; this name deprecated
                                        (0267)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0268)    mov   A, reg[PWM16_1_COMPARE_MSB_REG]
                                        (0269)    mov   X, A
                                        (0270)    mov   A, reg[PWM16_1_COMPARE_LSB_REG]
                                        (0271)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0272)    ret
                                        (0273) 
                                        (0274) 
                                        (0275) .ENDSECTION
                                        (0276) 
                                        (0277) .SECTION
                                        (0278) ;-----------------------------------------------------------------------------
                                        (0279) ;  FUNCTION NAME: PWM16_1_wReadCounter
                                        (0280) ;
                                        (0281) ;  DESCRIPTION:
                                        (0282) ;     Returns the value in the Count register (DR0), preserving the value in
                                        (0283) ;     the compare register (DR2). Interrupts are prevented during the transfer
                                        (0284) ;     from the Count to the Compare register by holding the clock low in
                                        (0285) ;     the MSB PSoC block.
                                        (0286) ;-----------------------------------------------------------------------------
                                        (0287) ;
                                        (0288) ;  ARGUMENTS: None
                                        (0289) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                        (0290) ;  SIDE EFFECTS:
                                        (0291) ;     1) The user module is stopped momentarily and one or more counts may be missed.
                                        (0292) ;     2) The A and X registers may be modified by this or future implementations
                                        (0293) ;        of this function.  The same is true for all RAM page pointer registers in
                                        (0294) ;        the Large Memory Model.  When necessary, it is the calling function's
                                        (0295) ;        responsibility to perserve their values across calls to fastcall16 
                                        (0296) ;        functions.
                                        (0297) ;
                                        (0298)  PWM16_1_wReadCounter:
                                        (0299) _PWM16_1_wReadCounter:
                                        (0300)  wPWM16_1_ReadCounter:                           ; this name deprecated
                                        (0301) _wPWM16_1_ReadCounter:                           ; this name deprecated
                                        (0302) 
                                        (0303)    bOrigCompareValue:      EQU   0                  ; Frame offset to temp Compare store
                                        (0304)    bOrigClockSetting:      EQU   2                  ; Frame offset to temp Input   store
                                        (0305)    wCounter:               EQU   3                  ; Frame offset to temp Count   store
                                        (0306)    STACK_FRAME_SIZE:       EQU   5                  ; max stack frame size is 5 bytes
                                        (0307) 
                                        (0308)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0309)    mov   X, SP                                      ; X <-  stack frame pointer
                                        (0310)    mov   A, reg[PWM16_1_COMPARE_MSB_REG]         ; Save the Compare register on the stack
                                        (0311)    push  A                                          ;
                                        (0312)    mov   A, reg[PWM16_1_COMPARE_LSB_REG]         ;
                                        (0313)    push  A                                          ;  -stack frame now 2 bytes-
                                        (0314)    PWM16_1_Stop_M                                ; Disable the PWM function
                                        (0315)    M8C_SetBank1                                     ;
                                        (0316)    mov   A, reg[PWM16_1_INPUT_LSB_REG]           ; save the LSB clock input setting
                                        (0317)    push  A                                          ;   on the stack (now 3 bytes) and ...
                                        (0318)                                                     ;   hold the clock low:
                                        (0319)    mov   reg[PWM16_1_INPUT_LSB_REG], INPUT_REG_NULL
                                        (0320)    M8C_SetBank0                                     ; Extract the Count via DR2 register
                                        (0321)    mov   A, reg[PWM16_1_COUNTER_MSB_REG]         ; DR2 <- DR0 (in the MSB block)
                                        (0322)    mov   A, reg[PWM16_1_COMPARE_MSB_REG]         ; Stash the Count MSB on the stack
                                        (0323)    push  A                                          ;  -stack frame is now 4 bytes
                                        (0324)    mov   A, reg[PWM16_1_COUNTER_LSB_REG]         ; DR2 <- DR0 (in the LSB block)
                                        (0325)    mov   A, reg[PWM16_1_COMPARE_LSB_REG]         ; Stash the Count LSB on the stack
                                        (0326)    push  A                                          ;   -stack frame is now 5 bytes-
                                        (0327)    mov   A, [X+bOrigCompareValue]                   ; Restore the Compare MSB register
                                        (0328)    mov   reg[PWM16_1_COMPARE_MSB_REG], A         ;
                                        (0329)    mov   A, [X+bOrigCompareValue+1]                 ; Restore the Compare LSB register
                                        (0330)    mov   reg[PWM16_1_COMPARE_LSB_REG], A         ;
                                        (0331)    M8C_SetBank1                                     ; ---Restore the PWM operation
                                        (0332)    mov   A, [X+bOrigClockSetting]                   ; Grab the LSB clock setting...
                                        (0333)    mov   reg[PWM16_1_INPUT_LSB_REG], A           ;    and restore it
                                        (0334)    M8C_SetBank0                                     ;
                                        (0335)    PWM16_1_Start_M                               ; Now re-enable the PWM function
                                        (0336)    pop   A                                          ; Setup the return value
                                        (0337)    pop   X                                          ;
                                        (0338)    ADD   SP, -(STACK_FRAME_SIZE-2)                  ; Zap remainder of stack frame
                                        (0339)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0340)    ret
                                        (0341) 
                                        (0342) .ENDSECTION
                                        (0343) 
                                        (0344) ; End of File PWM16_1.asm
FILE: lib\counter8_1int.asm             (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
0277: 08       PUSH  A                  (0003) ;;  FILENAME: Counter8_1INT.asm
                                        (0004) ;;   Version: 2.60, Updated on 2014/7/14 at 8:9:2
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: Counter8 Interrupt Service Routine
                                        (0008) ;;-----------------------------------------------------------------------------
0278: 51 17    MOV   A,[__r0]           (0009) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
027A: 08       PUSH  A                  (0010) ;;*****************************************************************************
027B: 51 16    MOV   A,[__r1]           (0011) ;;*****************************************************************************
027D: 08       PUSH  A                  (0012) 
027E: 51 15    MOV   A,[__r2]           (0013) include "m8c.inc"
0280: 08       PUSH  A                  (0014) include "memory.inc"
0281: 51 14    MOV   A,[__r3]           (0015) include "Counter8_1.inc"
0283: 08       PUSH  A                  (0016) 
0284: 51 13    MOV   A,[__r4]           (0017) 
0286: 08       PUSH  A                  (0018) ;-----------------------------------------------
0287: 51 12    MOV   A,[__r5]           (0019) ;  Global Symbols
0289: 08       PUSH  A                  (0020) ;-----------------------------------------------
028A: 51 11    MOV   A,[__r6]           (0021) export  _Counter8_1_ISR
028C: 08       PUSH  A                  (0022) 
028D: 51 10    MOV   A,[__r7]           (0023) 
028F: 08       PUSH  A                  (0024) AREA InterruptRAM (RAM,REL,CON)
0290: 51 0F    MOV   A,[__r8]           (0025) 
0292: 08       PUSH  A                  (0026) ;@PSoC_UserCode_INIT@ (Do not change this line.)
0293: 51 0E    MOV   A,[__r9]           (0027) ;---------------------------------------------------
0295: 08       PUSH  A                  (0028) ; Insert your custom declarations below this banner
0296: 51 0D    MOV   A,[__r10]          (0029) ;---------------------------------------------------
0298: 08       PUSH  A                  (0030) 
0299: 51 0C    MOV   A,[__r11]          (0031) ;------------------------
029B: 08       PUSH  A                  (0032) ; Includes
029C: 51 0B    MOV   A,[__rX]           (0033) ;------------------------
029E: 08       PUSH  A                  (0034) 
029F: 51 0A    MOV   A,[__rY]           (0035) 	
02A1: 08       PUSH  A                  (0036) ;------------------------
02A2: 51 09    MOV   A,[__rZ]           (0037) ;  Constant Definitions
02A4: 08       PUSH  A                  (0038) ;------------------------
                                        (0039) 
                                        (0040) 
                                        (0041) ;------------------------
                                        (0042) ; Variable Allocation
                                        (0043) ;------------------------
                                        (0044) 
                                        (0045) 
                                        (0046) ;---------------------------------------------------
                                        (0047) ; Insert your custom declarations above this banner
                                        (0048) ;---------------------------------------------------
                                        (0049) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0050) 
                                        (0051) 
                                        (0052) AREA UserModules (ROM, REL)
                                        (0053) 
                                        (0054) ;-----------------------------------------------------------------------------
                                        (0055) ;  FUNCTION NAME: _Counter8_1_ISR
                                        (0056) ;
                                        (0057) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0058) ;
                                        (0059) ;-----------------------------------------------------------------------------
                                        (0060) ;
                                        (0061) 
                                        (0062) _Counter8_1_ISR:
                                        (0063) 
                                        (0064)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0065)    ;---------------------------------------------------
                                        (0066)    ; Insert your custom assembly code below this banner
                                        (0067)    ;---------------------------------------------------
                                        (0068)    ;   NOTE: interrupt service routines must preserve
                                        (0069)    ;   the values of the A and X CPU registers.
                                        (0070)    
                                        (0071)    ;---------------------------------------------------
                                        (0072)    ; Insert your custom assembly code above this banner
                                        (0073)    ;---------------------------------------------------
                                        (0074)    
                                        (0075)    ;---------------------------------------------------
                                        (0076)    ; Insert a lcall to a C function below this banner
                                        (0077)    ; and un-comment the lines between these banners
                                        (0078)    ;---------------------------------------------------
                                        (0079)    
                                        (0080)    PRESERVE_CPU_CONTEXT
02A5: 7C 07 6C LCALL _TMR8_1_Interrupt  (0081)    lcall _TMR8_1_Interrupt
02A8: 18       POP   A                  
02A9: 53 09    MOV   [__rZ],A           
02AB: 18       POP   A                  
02AC: 53 0A    MOV   [__rY],A           
02AE: 18       POP   A                  
02AF: 53 0B    MOV   [__rX],A           
02B1: 18       POP   A                  
02B2: 53 0C    MOV   [__r11],A          
02B4: 18       POP   A                  
02B5: 53 0D    MOV   [__r10],A          
02B7: 18       POP   A                  
02B8: 53 0E    MOV   [__r9],A           
02BA: 18       POP   A                  
02BB: 53 0F    MOV   [__r8],A           
02BD: 18       POP   A                  
02BE: 53 10    MOV   [__r7],A           
02C0: 18       POP   A                  
02C1: 53 11    MOV   [__r6],A           
02C3: 18       POP   A                  
02C4: 53 12    MOV   [__r5],A           
02C6: 18       POP   A                  
02C7: 53 13    MOV   [__r4],A           
02C9: 18       POP   A                  
02CA: 53 14    MOV   [__r3],A           
02CC: 18       POP   A                  
02CD: 53 15    MOV   [__r2],A           
02CF: 18       POP   A                  
02D0: 53 16    MOV   [__r1],A           
02D2: 18       POP   A                  
02D3: 53 17    MOV   [__r0],A           
02D5: 18       POP   A                  
                                        (0082)    RESTORE_CPU_CONTEXT
                                        (0083)    
                                        (0084)    ;---------------------------------------------------
                                        (0085)    ; Insert a lcall to a C function above this banner
                                        (0086)    ; and un-comment the lines between these banners
                                        (0087)    ;---------------------------------------------------
                                        (0088)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0089) 
02D6: 7E       RETI                     (0090)    reti
                                        (0091) 
                                        (0092) 
                                        (0093) ; end of file Counter8_1INT.asm
FILE: lib\counter8_1.asm                (0001) ;;*****************************************************************************
02D7: 43 E1 08 OR    REG[0xE1],0x8      (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: Counter8_1.asm
                                        (0004) ;;   Version: 2.60, Updated on 2014/7/14 at 8:9:2
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: Counter8 User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "memory.inc"
                                        (0024) include "Counter8_1.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export  Counter8_1_EnableInt
                                        (0030) export _Counter8_1_EnableInt
                                        (0031) export  Counter8_1_DisableInt
                                        (0032) export _Counter8_1_DisableInt
                                        (0033) export  Counter8_1_Start
                                        (0034) export _Counter8_1_Start
                                        (0035) export  Counter8_1_Stop
                                        (0036) export _Counter8_1_Stop
                                        (0037) export  Counter8_1_WritePeriod
                                        (0038) export _Counter8_1_WritePeriod
                                        (0039) export  Counter8_1_WriteCompareValue
                                        (0040) export _Counter8_1_WriteCompareValue
                                        (0041) export  Counter8_1_bReadCompareValue
                                        (0042) export _Counter8_1_bReadCompareValue
                                        (0043) export  Counter8_1_bReadCounter
                                        (0044) export _Counter8_1_bReadCounter
                                        (0045) 
                                        (0046) ; The following functions are deprecated and subject to omission in future releases
                                        (0047) ;
                                        (0048) export  bCounter8_1_ReadCompareValue  ; deprecated
                                        (0049) export _bCounter8_1_ReadCompareValue  ; deprecated
                                        (0050) export  bCounter8_1_ReadCounter       ; deprecated
                                        (0051) export _bCounter8_1_ReadCounter       ; deprecated
                                        (0052) 
                                        (0053) ;-----------------------------------------------
                                        (0054) ;  Constant Definitions
                                        (0055) ;-----------------------------------------------
                                        (0056) INPUT_REG_NULL:                equ 0x00    ; Clear the input register
                                        (0057) 
                                        (0058) 
                                        (0059) AREA UserModules (ROM, REL)
                                        (0060) 
                                        (0061) .SECTION
                                        (0062) ;-----------------------------------------------------------------------------
                                        (0063) ;  FUNCTION NAME: Counter8_1_EnableInt
                                        (0064) ;
                                        (0065) ;  DESCRIPTION:
                                        (0066) ;     Enables this counter's interrupt by setting the interrupt enable mask bit
                                        (0067) ;     associated with this User Module. This function has no effect until and
                                        (0068) ;     unless the global interrupts are enabled (for example by using the
                                        (0069) ;     macro M8C_EnableGInt).
                                        (0070) ;-----------------------------------------------------------------------------
                                        (0071) ;
                                        (0072) ;  ARGUMENTS:    None.
                                        (0073) ;  RETURNS:      Nothing.
                                        (0074) ;  SIDE EFFECTS: 
                                        (0075) ;    The A and X registers may be modified by this or future implementations
                                        (0076) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0077) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0078) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0079) ;    functions.
                                        (0080) ;
                                        (0081)  Counter8_1_EnableInt:
                                        (0082) _Counter8_1_EnableInt:
                                        (0083)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0084)    Counter8_1_EnableInt_M
                                        (0085)    RAM_EPILOGUE RAM_USE_CLASS_1
02DA: 7F       RET                      (0086)    ret
02DB: 43 2F 01 OR    REG[0x2F],0x1      
                                        (0087) 
                                        (0088) .ENDSECTION
                                        (0089) 
                                        (0090) .SECTION
                                        (0091) ;-----------------------------------------------------------------------------
                                        (0092) ;  FUNCTION NAME: Counter8_1_DisableInt
                                        (0093) ;
                                        (0094) ;  DESCRIPTION:
                                        (0095) ;     Disables this counter's interrupt by clearing the interrupt enable
                                        (0096) ;     mask bit associated with this User Module.
                                        (0097) ;-----------------------------------------------------------------------------
                                        (0098) ;
                                        (0099) ;  ARGUMENTS:    None
                                        (0100) ;  RETURNS:      Nothing
                                        (0101) ;  SIDE EFFECTS: 
                                        (0102) ;    The A and X registers may be modified by this or future implementations
                                        (0103) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0104) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0105) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0106) ;    functions.
                                        (0107) ;
                                        (0108)  Counter8_1_DisableInt:
                                        (0109) _Counter8_1_DisableInt:
                                        (0110)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0111)    Counter8_1_DisableInt_M
                                        (0112)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0113)    ret
                                        (0114) 
                                        (0115) 
                                        (0116) .ENDSECTION
                                        (0117) 
                                        (0118) .SECTION
                                        (0119) ;-----------------------------------------------------------------------------
                                        (0120) ;  FUNCTION NAME: Counter8_1_Start
                                        (0121) ;
                                        (0122) ;  DESCRIPTION:
                                        (0123) ;     Sets the start bit in the Control register of this user module.  The
                                        (0124) ;     counter will begin counting on the next input clock as soon as the
                                        (0125) ;     enable input is asserted high.
                                        (0126) ;-----------------------------------------------------------------------------
                                        (0127) ;
                                        (0128) ;  ARGUMENTS:    None
                                        (0129) ;  RETURNS:      Nothing
                                        (0130) ;  SIDE EFFECTS: 
                                        (0131) ;    The A and X registers may be modified by this or future implementations
                                        (0132) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0133) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0134) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0135) ;    functions.
                                        (0136) ;
                                        (0137)  Counter8_1_Start:
                                        (0138) _Counter8_1_Start:
                                        (0139)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0140)    Counter8_1_Start_M
                                        (0141)    RAM_EPILOGUE RAM_USE_CLASS_1
02DE: 7F       RET                      (0142)    ret
                                        (0143) 
                                        (0144) 
                                        (0145) .ENDSECTION
                                        (0146) 
                                        (0147) .SECTION
                                        (0148) ;-----------------------------------------------------------------------------
                                        (0149) ;  FUNCTION NAME: Counter8_1_Stop
                                        (0150) ;
                                        (0151) ;  DESCRIPTION:
                                        (0152) ;     Disables counter operation by clearing the start bit in the Control
                                        (0153) ;     register.
                                        (0154) ;-----------------------------------------------------------------------------
                                        (0155) ;
                                        (0156) ;  ARGUMENTS:    None
                                        (0157) ;  RETURNS:      Nothing
                                        (0158) ;  SIDE EFFECTS: 
                                        (0159) ;    The A and X registers may be modified by this or future implementations
                                        (0160) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0161) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0162) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0163) ;    functions.
                                        (0164) ;
                                        (0165)  Counter8_1_Stop:
                                        (0166) _Counter8_1_Stop:
                                        (0167)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0168)    Counter8_1_Stop_M
                                        (0169)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0170)    ret
                                        (0171) 
                                        (0172) 
                                        (0173) .ENDSECTION
                                        (0174) 
                                        (0175) .SECTION
                                        (0176) ;-----------------------------------------------------------------------------
                                        (0177) ;  FUNCTION NAME: Counter8_1_WritePeriod
                                        (0178) ;
                                        (0179) ;  DESCRIPTION:
                                        (0180) ;     Write the 8-bit period value into the Period register (DR1).
                                        (0181) ;-----------------------------------------------------------------------------
                                        (0182) ;
                                        (0183) ;  ARGUMENTS: fastcall16 BYTE bPeriodValue (passed in A)
                                        (0184) ;  RETURNS:   Nothing
                                        (0185) ;  SIDE EFFECTS:
                                        (0186) ;    If the counter user module is stopped, then this value will also be
                                        (0187) ;    latched into the Count register (DR0).
                                        (0188) ;     
                                        (0189) ;    The A and X registers may be modified by this or future implementations
                                        (0190) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0191) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0192) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0193) ;    functions.
                                        (0194) ;
                                        (0195)  Counter8_1_WritePeriod:
                                        (0196) _Counter8_1_WritePeriod:
                                        (0197)    RAM_PROLOGUE RAM_USE_CLASS_1
02DF: 60 2D    MOV   REG[0x2D],A        (0198)    mov   reg[Counter8_1_PERIOD_REG], A
                                        (0199)    RAM_EPILOGUE RAM_USE_CLASS_1
02E1: 7F       RET                      (0200)    ret
                                        (0201) 
                                        (0202) 
                                        (0203) .ENDSECTION
                                        (0204) 
                                        (0205) .SECTION
                                        (0206) ;-----------------------------------------------------------------------------
                                        (0207) ;  FUNCTION NAME: Counter8_1_WriteCompareValue
                                        (0208) ;
                                        (0209) ;  DESCRIPTION:
                                        (0210) ;     Writes compare value into the Compare register (DR2).
                                        (0211) ;-----------------------------------------------------------------------------
                                        (0212) ;
                                        (0213) ;  ARGUMENTS:    fastcall16 BYTE bCompareValue (passed in A)
                                        (0214) ;  RETURNS:      Nothing
                                        (0215) ;  SIDE EFFECTS: 
                                        (0216) ;    The A and X registers may be modified by this or future implementations
                                        (0217) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0218) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0219) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0220) ;    functions.
                                        (0221) ;
                                        (0222)  Counter8_1_WriteCompareValue:
                                        (0223) _Counter8_1_WriteCompareValue:
                                        (0224)    RAM_PROLOGUE RAM_USE_CLASS_1
02E2: 60 2E    MOV   REG[0x2E],A        (0225)    mov   reg[Counter8_1_COMPARE_REG], A
                                        (0226)    RAM_EPILOGUE RAM_USE_CLASS_1
02E4: 7F       RET                      (0227)    ret
                                        (0228) 
                                        (0229) 
                                        (0230) .ENDSECTION
                                        (0231) 
                                        (0232) .SECTION
                                        (0233) ;-----------------------------------------------------------------------------
                                        (0234) ;  FUNCTION NAME: Counter8_1_bReadCompareValue
                                        (0235) ;
                                        (0236) ;  DESCRIPTION:
                                        (0237) ;     Reads the Compare register.
                                        (0238) ;-----------------------------------------------------------------------------
                                        (0239) ;
                                        (0240) ;  ARGUMENTS:    None
                                        (0241) ;  RETURNS:      fastcall16 BYTE bCompareValue (value of DR2 in the A register)
                                        (0242) ;  SIDE EFFECTS: 
                                        (0243) ;    The A and X registers may be modified by this or future implementations
                                        (0244) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0245) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0246) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0247) ;    functions.
                                        (0248) ;
                                        (0249)  Counter8_1_bReadCompareValue:
                                        (0250) _Counter8_1_bReadCompareValue:
                                        (0251)  bCounter8_1_ReadCompareValue:                   ; this name deprecated
                                        (0252) _bCounter8_1_ReadCompareValue:                   ; this name deprecated
                                        (0253)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0254)    mov   A, reg[Counter8_1_COMPARE_REG]
                                        (0255)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0256)    ret
                                        (0257) 
                                        (0258) 
                                        (0259) .ENDSECTION
                                        (0260) 
                                        (0261) .SECTION
                                        (0262) ;-----------------------------------------------------------------------------
                                        (0263) ;  FUNCTION NAME: Counter8_1_bReadCounter
                                        (0264) ;
                                        (0265) ;  DESCRIPTION:
                                        (0266) ;     Returns the value in the Count register (DR0), preserving the value in
                                        (0267) ;     the compare register (DR2). Interrupts are prevented during the transfer
                                        (0268) ;     from the Count to the Compare registers by holding the clock low in
                                        (0269) ;     the PSoC block.
                                        (0270) ;-----------------------------------------------------------------------------
                                        (0271) ;
                                        (0272) ;  ARGUMENTS: None
                                        (0273) ;  RETURNS:   fastcall16 BYTE bCount (value of DR0 in the A register)
                                        (0274) ;  SIDE EFFECTS:
                                        (0275) ;     1) If running, the user module is stopped momentarily and one or more
                                        (0276) ;        counts may be missed.
                                        (0277) ;     2) The A and X registers may be modified by this or future implementations
                                        (0278) ;        of this function.  The same is true for all RAM page pointer registers in
                                        (0279) ;        the Large Memory Model.  When necessary, it is the calling function's
                                        (0280) ;        responsibility to perserve their values across calls to fastcall16 
                                        (0281) ;        functions.
                                        (0282) ;
                                        (0283)  Counter8_1_bReadCounter:
                                        (0284) _Counter8_1_bReadCounter:
                                        (0285)  bCounter8_1_ReadCounter:                        ; this name deprecated
                                        (0286) _bCounter8_1_ReadCounter:                        ; this name deprecated
                                        (0287) 
                                        (0288)    bOrigCompareValue:      EQU   0               ; Frame offset to temp Compare store
                                        (0289)    bOrigControlReg:        EQU   1               ; Frame offset to temp CR0     store
                                        (0290)    bOrigClockSetting:      EQU   2               ; Frame offset to temp Input   store
                                        (0291)    wCounter:               EQU   3               ; Frame offset to temp Count   store
                                        (0292)    STACK_FRAME_SIZE:       EQU   4               ; max stack frame size is 4 bytes
                                        (0293) 
                                        (0294)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0295)    mov   X, SP                                   ; X <- stack frame pointer
                                        (0296)    mov   A, reg[Counter8_1_COMPARE_REG]          ; Save the Compare register on the stack
                                        (0297)    push  A                                       ;
                                        (0298)    mov   A, reg[Counter8_1_CONTROL_REG]          ; Save CR0 (running or stopped state)
                                        (0299)    push  A                                       ;
                                        (0300)    Counter8_1_Stop_M                             ; Disable (stop) the Counter if running
                                        (0301)    M8C_SetBank1                                  ;
                                        (0302)    mov   A, reg[Counter8_1_INPUT_REG]            ; save the clock input setting
                                        (0303)    push  A                                       ;   on the stack (now 2 bytes) and ...
                                        (0304)                                                  ;   hold the clock low:
                                        (0305)    mov   reg[Counter8_1_INPUT_REG], INPUT_REG_NULL
                                        (0306)    M8C_SetBank0
                                        (0307)                                                  ; Extract the Count via DR2 register
                                        (0308)    mov   A, reg[Counter8_1_COUNTER_REG]          ; DR2 <- DR0
                                        (0309)    mov   A, reg[Counter8_1_COMPARE_REG]          ; Stash the Count on the stack
                                        (0310)    push  A                                       ;  -stack frame is now 3 bytes
                                        (0311)    mov   A, [X+bOrigCompareValue]                ; Restore the Compare register
                                        (0312)    mov   reg[Counter8_1_COMPARE_REG], A
                                        (0313)    M8C_SetBank1                                  ; Restore the counter operation:
                                        (0314)    mov   A, [X+bOrigClockSetting]                ;   First, the clock setting...
                                        (0315)    mov   reg[Counter8_1_INPUT_REG], A            ;
                                        (0316)    M8C_SetBank0                                  ;   then re-enable (start) the counter
                                        (0317)    mov   A, [X+bOrigControlReg]                  ;     if it was running when
                                        (0318)    mov   reg[Counter8_1_CONTROL_REG], A          ;     this function was first called
                                        (0319)    pop   A                                       ; Setup the return value
                                        (0320)    ADD   SP, -(STACK_FRAME_SIZE-1)               ; Zap remainder of stack frame
                                        (0321)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0322)    ret
                                        (0323) 
                                        (0324) .ENDSECTION
                                        (0325) 
                                        (0326) ; End of File Counter8_1.asm
FILE: E:\WORKSP~1\DSM2PPM\PSOCDE~1\SATELI~2\SATELI~1\SATELI~1\dsm_remote.c
(0001) /*this module does contain the code to extract the data from
(0002) *the serial stream from the sattelite reciver
(0003) * the first byte ist a lost frame counter
(0004) * the second byte is a transmitter capability byte
(0005) * 0x1 DSM2 less that 8 chanal 1024 Bit 
(0006) * 0x2 DSM2 8 or more chanal 1024 Bit
(0007) * 0x11/0x12 like 0x1/0x2 but 2048 Bit
(0008) *next is the chanal data, one chanal per WORD
(0009) *BITS: the lowes 10/11 bit is the chanal value, right above (4 Bit) is the chanal Number
(0010) * xxCCCCVVVVVVVVVV (10 bit) or xCCCCVVVVVVVVVVV (11Bit)
(0011) */
(0012) #include <m8c.h>        // part specific constants and macros
(0013) #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
(0014) #include "DSM_Remote.h"
(0015) #include "ppm.h"
(0016) #include "serial.h"
(0017) #include "timer.h"
(0018) 
(0019) BOOL BindMode=0;
(0020) 
(0021) //determin if we got 10 or 11 Bit data
(0022) //first check the transmiter capability  byte
(0023) //else tryout
(0024) BYTE DSM_DeterminBitCount(void)
(0025) {
_bCounter8_1_ReadCounter|_Counter8_1_bReadCounter|_bCounter8_1_ReadCompareValue|__UserModules_end|bCounter8_1_ReadCounter|_Counter8_1_bReadCompareValue|bCounter8_1_ReadCompareValue|__text_start|_DSM_DeterminBitCount|_DSM_DeterminBitCount:
  min                  --> X+3
  max                  --> X+2
  n                    --> X+1
  chanal               --> X+0
    02E5: 10       PUSH  X
    02E6: 4F       MOV   X,SP
    02E7: 38 04    ADD   SP,0x4
(0026) 	//check capability byte first
(0027) 	/*if (ser_databuf[1]!=0)
(0028) 	{
(0029) 		if ((ser_databuf[1]&0xF)<=3)
(0030) 		{
(0031) 			if (ser_databuf[1]&0x10)
(0032) 				return 11;
(0033) 			else 
(0034) 				return 10;
(0035) 		}
(0036) 	}*/
(0037) 	//else tryout
(0038) 	{
(0039) 		BYTE min=0xff;
    02E9: 56 03 FF MOV   [X+3],0xFF
(0040) 		BYTE max=0;
    02EC: 56 02 00 MOV   [X+2],0x0
(0041) 		BYTE chanal;
(0042) 		BYTE n;
(0043) 		//try 10 Bits
(0044) 		for (n=0;n<7;n++)
    02EF: 56 01 00 MOV   [X+1],0x0
    02F2: 80 38    JMP   0x032B
(0045) 		{
(0046) 			chanal=(ser_databuf[n*2+2]>>2)&0xF;
    02F4: 52 01    MOV   A,[X+1]
    02F6: 64       ASL   A
    02F7: 01 2F    ADD   A,0x2F
    02F9: 53 16    MOV   [__r1],A
    02FB: 3E 16    MVI   A,[__r1]
    02FD: 67       ASR   A
    02FE: 67       ASR   A
    02FF: 21 0F    AND   A,0xF
    0301: 54 00    MOV   [X+0],A
(0047) 			if (chanal && chanal<min)
    0303: 3D 00 00 CMP   [X+0],0x0
    0306: A0 0B    JZ    0x0312
    0308: 52 00    MOV   A,[X+0]
    030A: 3B 03    CMP   A,[X+3]
    030C: D0 05    JNC   0x0312
(0048) 				min=chanal;
    030E: 52 00    MOV   A,[X+0]
    0310: 54 03    MOV   [X+3],A
(0049) 			if(ser_databuf[n*2+2]!=0xFF  && chanal>max)
    0312: 52 01    MOV   A,[X+1]
    0314: 64       ASL   A
    0315: 01 2F    ADD   A,0x2F
    0317: 53 16    MOV   [__r1],A
    0319: 3E 16    MVI   A,[__r1]
    031B: 39 FF    CMP   A,0xFF
    031D: A0 0B    JZ    0x0329
    031F: 52 02    MOV   A,[X+2]
    0321: 3B 00    CMP   A,[X+0]
    0323: D0 05    JNC   0x0329
(0050) 				max=chanal;
    0325: 52 00    MOV   A,[X+0]
    0327: 54 02    MOV   [X+2],A
(0051) 		}		
    0329: 77 01    INC   [X+1]
    032B: 3D 01 07 CMP   [X+1],0x7
    032E: CF C5    JC    0x02F4
(0052) 		if (min==1 &&  max && max <7)
    0330: 3D 03 01 CMP   [X+3],0x1
    0333: B0 0F    JNZ   0x0343
    0335: 3D 02 00 CMP   [X+2],0x0
    0338: A0 0A    JZ    0x0343
    033A: 3D 02 07 CMP   [X+2],0x7
    033D: D0 05    JNC   0x0343
(0053) 			return 10;
    033F: 50 0A    MOV   A,0xA
    0341: 80 03    JMP   0x0345
(0054) 		else 
(0055) 			return 11;
    0343: 50 0B    MOV   A,0xB
    0345: 38 FC    ADD   SP,0xFC
    0347: 20       POP   X
    0348: 7F       RET   
(0056) 	}
(0057) }
(0058) 
(0059) //Extract chanal data from serial data
(0060) BOOL DSM_process_Data(void)
(0061) {
_DSM_process_Data:
  n                    --> X+0
    0349: 10       PUSH  X
    034A: 4F       MOV   X,SP
    034B: 38 01    ADD   SP,0x1
(0062) 
(0063) static BYTE bits;	
(0064) 	if (!bits) //check if we have 10 or 11 Bit data
    034D: 3C 18 00 CMP   [0x18],0x0
    0350: B0 05    JNZ   0x0356
(0065) 		bits=DSM_DeterminBitCount();
    0352: 9F 91    CALL  _bCounter8_1_ReadCounter|_Counter8_1_bReadCounter|_bCounter8_1_ReadCompareValue|__UserModules_end|bCounter8_1_ReadCounter|_Counter8_1_bReadCompareValue|bCounter8_1_ReadCompareValue|__text_start|_DSM_DeterminBitCount|_DSM_DeterminBitCount
    0354: 53 18    MOV   [0x18],A
(0066) 	if (bits)
    0356: 3C 18 00 CMP   [0x18],0x0
    0359: A0 FB    JZ    0x0455
(0067) 	{
(0068) 	BYTE n;
(0069) 	//static to safe stack space		
(0070) 	static BYTE chanal; 
(0071) 	static WORD value;	
(0072) 		//loop thru the words 
(0073) 		for (n=0;n<7;n++)
    035B: 56 00 00 MOV   [X+0],0x0
    035E: 80 ED    JMP   0x044C
(0074) 		{	//extract chanal number
(0075) 			if (bits==10)
    0360: 3C 18 0A CMP   [0x18],0xA
    0363: B0 0A    JNZ   0x036E
    0365: 94 41    CALL  0x07A8
    0367: 40       NOP   
(0076) 				chanal=(ser_databuf[n*2+2]>>2)&0xF;
    0368: 21 0F    AND   A,0xF
    036A: 53 19    MOV   [0x19],A
    036C: 80 09    JMP   0x0376
(0077) 			else 
(0078) 				chanal=(ser_databuf[n*2+2]>>3)&0xF;
    036E: 94 38    CALL  0x07A8
    0370: 40       NOP   
    0371: 67       ASR   A
    0372: 21 0F    AND   A,0xF
    0374: 53 19    MOV   [0x19],A
(0079) 			//check if chanal numer is in range
(0080) 			if (chanal<PPM_PULSE_COUNT && ser_databuf[n*2+2]!=0xFF)
    0376: 3C 19 08 CMP   [0x19],0x8
    0379: D0 D0    JNC   0x044A
    037B: 52 00    MOV   A,[X+0]
    037D: 64       ASL   A
    037E: 01 2F    ADD   A,0x2F
    0380: 53 16    MOV   [__r1],A
    0382: 3E 16    MVI   A,[__r1]
    0384: 39 FF    CMP   A,0xFF
    0386: A0 C3    JZ    0x044A
(0081) 				//extract chanal value
(0082) 			{
(0083) 				if (bits==10)
    0388: 3C 18 0A CMP   [0x18],0xA
    038B: B0 21    JNZ   0x03AD
(0084) 				{
(0085) 					value=(((WORD)ser_databuf[n*2+2]<<8)+ser_databuf[n*2+3])&0x3FF;
    038D: 52 00    MOV   A,[X+0]
    038F: 64       ASL   A
    0390: 53 16    MOV   [__r1],A
    0392: 01 30    ADD   A,0x30
    0394: 53 14    MOV   [__r3],A
    0396: 3E 14    MVI   A,[__r3]
    0398: 53 15    MOV   [__r2],A
    039A: 06 16 2F ADD   [__r1],0x2F
    039D: 3E 16    MVI   A,[__r1]
    039F: 53 17    MOV   [__r0],A
    03A1: 51 15    MOV   A,[__r2]
    03A3: 53 1B    MOV   [0x1B],A
    03A5: 51 17    MOV   A,[__r0]
    03A7: 21 03    AND   A,0x3
    03A9: 53 1A    MOV   [0x1A],A
(0086) 				}
    03AB: 80 1F    JMP   0x03CB
(0087) 				else
(0088) 				{
(0089) 					value=(((WORD)ser_databuf[n*2+2]<<8)+ser_databuf[n*2+3])&0x7FF;
    03AD: 52 00    MOV   A,[X+0]
    03AF: 64       ASL   A
    03B0: 53 16    MOV   [__r1],A
    03B2: 01 30    ADD   A,0x30
    03B4: 53 14    MOV   [__r3],A
    03B6: 3E 14    MVI   A,[__r3]
    03B8: 53 15    MOV   [__r2],A
    03BA: 06 16 2F ADD   [__r1],0x2F
    03BD: 3E 16    MVI   A,[__r1]
    03BF: 53 17    MOV   [__r0],A
    03C1: 51 15    MOV   A,[__r2]
    03C3: 53 1B    MOV   [0x1B],A
    03C5: 51 17    MOV   A,[__r0]
    03C7: 21 07    AND   A,0x7
    03C9: 53 1A    MOV   [0x1A],A
(0090) 				}
(0091) 				//PPM has resulution of 2000/1ms so 10 Bit datta (0 to 1024) needs to be multipleid by 2
(0092) 				//best would be a linear scale like "Value=PPM_MIN + (value*(PPM_MAX-PPM_MIN))/(1<<Bits)" but that takes to mutch time.
(0093) 				if (bits==10)
    03CB: 3C 18 0A CMP   [0x18],0xA
    03CE: B0 23    JNZ   0x03F2
(0094) 					ppm_Data[chanal]=PPM_OUT_MIN_LEN+ value*2;
    03D0: 5F 16 1B MOV   [__r1],[0x1B]
    03D3: 5F 17 1A MOV   [__r0],[0x1A]
    03D6: 65 16    ASL   [__r1]
    03D8: 6B 17    RLC   [__r0]
    03DA: 06 16 B8 ADD   [__r1],0xB8
    03DD: 0E 17 07 ADC   [__r0],0x7
    03E0: 5F 14 19 MOV   [__r3],[0x19]
    03E3: 65 14    ASL   [__r3]
    03E5: 06 14 1C ADD   [__r3],0x1C
    03E8: 51 17    MOV   A,[__r0]
    03EA: 3F 14    MVI   [__r3],A
    03EC: 51 16    MOV   A,[__r1]
    03EE: 3F 14    MVI   [__r3],A
    03F0: 80 19    JMP   0x040A
(0095) 				else 
(0096) 					ppm_Data[chanal]=PPM_OUT_MIN_LEN+ value;
    03F2: 51 1B    MOV   A,[0x1B]
    03F4: 01 B8    ADD   A,0xB8
    03F6: 53 16    MOV   [__r1],A
    03F8: 51 1A    MOV   A,[0x1A]
    03FA: 09 07    ADC   A,0x7
    03FC: 5F 14 19 MOV   [__r3],[0x19]
    03FF: 65 14    ASL   [__r3]
    0401: 06 14 1C ADD   [__r3],0x1C
    0404: 3F 14    MVI   [__r3],A
    0406: 51 16    MOV   A,[__r1]
    0408: 3F 14    MVI   [__r3],A
(0097) 				//limit to MIN / MAX
(0098) 				if (PPM_OUT_MAX_LEN<ppm_Data[chanal])
    040A: 5F 16 19 MOV   [__r1],[0x19]
    040D: 93 8D    CALL  <created procedures>
    040F: 40       NOP   
    0410: 53 16    MOV   [__r1],A
    0412: 50 B8    MOV   A,0xB8
    0414: 12 16    SUB   A,[__r1]
    0416: 50 0F    MOV   A,0xF
    0418: 1A 17    SBB   A,[__r0]
    041A: D0 11    JNC   0x042C
(0099) 					ppm_Data[chanal]=PPM_OUT_MAX_LEN;
    041C: 5F 16 19 MOV   [__r1],[0x19]
    041F: 65 16    ASL   [__r1]
    0421: 06 16 1C ADD   [__r1],0x1C
    0424: 50 0F    MOV   A,0xF
    0426: 3F 16    MVI   [__r1],A
    0428: 50 B8    MOV   A,0xB8
    042A: 3F 16    MVI   [__r1],A
(0100) 				if (PPM_OUT_MIN_LEN>ppm_Data[chanal])
    042C: 5F 16 19 MOV   [__r1],[0x19]
    042F: 93 6B    CALL  <created procedures>
    0431: 40       NOP   
    0432: 11 B8    SUB   A,0xB8
    0434: 51 17    MOV   A,[__r0]
    0436: 19 07    SBB   A,0x7
    0438: D0 11    JNC   0x044A
(0101) 					ppm_Data[chanal]=PPM_OUT_MIN_LEN;
    043A: 5F 16 19 MOV   [__r1],[0x19]
    043D: 65 16    ASL   [__r1]
    043F: 06 16 1C ADD   [__r1],0x1C
    0442: 50 07    MOV   A,0x7
    0444: 3F 16    MVI   [__r1],A
    0446: 50 B8    MOV   A,0xB8
    0448: 3F 16    MVI   [__r1],A
(0102) 			}
(0103) 		}
    044A: 77 00    INC   [X+0]
    044C: 3D 00 07 CMP   [X+0],0x7
    044F: CF 10    JC    0x0360
(0104) 		return 1;
    0451: 50 01    MOV   A,0x1
    0453: 80 03    JMP   0x0457
(0105) 	}
(0106) 	return 0;
    0455: 50 00    MOV   A,0x0
    0457: 38 FF    ADD   SP,0xFF
    0459: 20       POP   X
    045A: 7F       RET   
(0107) }
(0108) 
(0109) //check if reciver is connected 
(0110) //if we power up without reciver is connected then wait for reciver connected an enter bind mode
(0111) void DSM_CheckForReciver(void)
(0112) {
_DSM_CheckForReciver:
  delay                --> X+0
    045B: 10       PUSH  X
    045C: 4F       MOV   X,SP
    045D: 38 01    ADD   SP,0x1
(0113) 	//check for Bind Jumper
(0114) 	PRT1DR&=~2; //Set output Low
    045F: 41 04 FD AND   REG[0x4],0xFD
(0115) 	TimerWait_ms(1);
    0462: 50 01    MOV   A,0x1
    0464: 08       PUSH  A
    0465: 7C 07 3F LCALL _TimerWait_ms
    0468: 38 FF    ADD   SP,0xFF
(0116) 	if (!(PRT1DR&1))
    046A: 5D 04    MOV   A,REG[0x4]
    046C: 53 17    MOV   [__r0],A
    046E: 47 17 01 TST   [__r0],0x1
    0471: B0 04    JNZ   0x0476
(0117) 	{
(0118) 		BindMode=1;
    0473: 55 00 01 MOV   [BindMode|bits|ser_c],0x1
(0119) 	}
(0120) 	
(0121) 	//wait for a High on the input from the satelite reciver
(0122) 	PRT0DR&=~(1<<5);
    0476: 41 00 DF AND   REG[0x0],0xDF
(0123) 	{
(0124) 		BYTE delay=0;
    0479: 56 00 00 MOV   [X+0],0x0
(0125) 		TimerWait_ms(10);	
    047C: 50 0A    MOV   A,0xA
    047E: 08       PUSH  A
    047F: 7C 07 3F LCALL _TimerWait_ms
    0482: 38 FF    ADD   SP,0xFF
    0484: 80 19    JMP   0x049E
(0126) 		while (!(PRT0DR&(1<<5)))  //wait for the satelite
(0127) 		{
(0128) 			TimerWait_ms(1);
    0486: 50 01    MOV   A,0x1
    0488: 08       PUSH  A
    0489: 7C 07 3F LCALL _TimerWait_ms
    048C: 38 FF    ADD   SP,0xFF
(0129) 			delay++;
    048E: 77 00    INC   [X+0]
(0130) 			//if we powered up without a connected reciver enter Bind mode
(0131) 			//and wait for the reciver to connect
(0132) 			if (!BindMode && delay>10)
    0490: 3C 00 00 CMP   [BindMode|bits|ser_c],0x0
    0493: B0 0A    JNZ   0x049E
    0495: 50 0A    MOV   A,0xA
    0497: 3B 00    CMP   A,[X+0]
    0499: D0 04    JNC   0x049E
(0133) 			{
(0134) 				BindMode=1;
    049B: 55 00 01 MOV   [BindMode|bits|ser_c],0x1
(0135) 			}
(0136) 		}
    049E: 5D 00    MOV   A,REG[0x0]
    04A0: 53 17    MOV   [__r0],A
    04A2: 47 17 20 TST   [__r0],0x20
    04A5: AF E0    JZ    0x0486
(0137) 	}
(0138) 	
(0139) 	if (BindMode)
    04A7: 3C 00 00 CMP   [BindMode|bits|ser_c],0x0
    04AA: A0 0F    JZ    0x04BA
(0140) 	{
(0141) 		TimerWait_ms(80);		
    04AC: 50 50    MOV   A,0x50
    04AE: 08       PUSH  A
    04AF: 7C 07 3F LCALL _TimerWait_ms
(0142) 		Timer_GennerateBindPulses(9);
    04B2: 50 09    MOV   A,0x9
    04B4: 08       PUSH  A
    04B5: 7C 07 24 LCALL _Timer_GennerateBindPulses
    04B8: 38 FE    ADD   SP,0xFE
(0143) 	}
    04BA: 38 FF    ADD   SP,0xFF
(0144) 
(0145) 	//found high signal on pin ->normal startup	
(0146) 
(0147) }FILE: E:\WORKSP~1\DSM2PPM\PSOCDE~1\SATELI~2\SATELI~1\SATELI~1\main.c
(0001) //----------------------------------------------------------------------------
(0002) // C main line
(0003) //----------------------------------------------------------------------------
(0004) 
(0005) #include <m8c.h>        // part specific constants and macros
(0006) #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
(0007) #include "ppm.h"
(0008) #include "serial.h"
(0009) #include "timer.h"
(0010) #include "DSM_Remote.h"
(0011) 
(0012) 
(0013) 
(0014) void main(void)
(0015) {
_main:
  new_data             --> X+0
    04BE: 10       PUSH  X
    04BF: 4F       MOV   X,SP
    04C0: 38 01    ADD   SP,0x1
(0016) BOOL new_data=0;
    04C2: 56 00 00 MOV   [X+0],0x0
(0017) 	//activate systick counter
(0018) 	TimerInit();
    04C5: 7C 07 04 LCALL _TimerInit
(0019) 	DSM_CheckForReciver();	
    04C8: 7C 04 5B LCALL _DSM_CheckForReciver
(0020) 	SerialRX_Init();
    04CB: 7C 06 18 LCALL _SerialRX_Init
(0021) 	ppm_Init();
    04CE: 7C 04 FC LCALL _ppm_Init
    04D1: 80 23    JMP   0x04F5
(0022) 	while (1)
(0023) 	{
(0024) 		if (SerialReadData())
    04D3: 7C 06 55 LCALL _SerialReadData
    04D6: 39 00    CMP   A,0x0
    04D8: A0 0C    JZ    0x04E5
(0025) 		{
(0026) 			new_data|=DSM_process_Data();
    04DA: 7C 03 49 LCALL _DSM_process_Data
    04DD: 2D 00    OR    [X+0],A
(0027) 			SER_RESET();
    04DF: 55 04 00 MOV   [ser_status],0x0
    04E2: 55 03 00 MOV   [ser_idx],0x0
(0028) 		}
(0029) 		if (PPM_IS_PPM_DONE())
    04E5: 3C 02 00 CMP   [ppm_Run|value],0x0
    04E8: B0 0C    JNZ   0x04F5
(0030) 		{
(0031) 			if (new_data)
    04EA: 3D 00 00 CMP   [X+0],0x0
    04ED: A0 07    JZ    0x04F5
(0032) 			{
(0033) 				new_data=0;	
    04EF: 56 00 00 MOV   [X+0],0x0
(0034) 				PPM_START_ONE_PPM_TRAIN();
    04F2: 55 02 01 MOV   [ppm_Run|value],0x1
(0035) 			}
(0036) 		}
(0037) 	}
    04F5: 8F DD    JMP   0x04D3
(0038) }
(0039) 
FILE: E:\WORKSP~1\DSM2PPM\PSOCDE~1\SATELI~2\SATELI~1\SATELI~1\ppm.c
(0001) /*
(0002) *PPM.C
(0003) *A 16 Bit PWM module  is used to gennerate the PPM train
(0004) *The PWM actually gennerates an inverted CPPM __|_|_|_|_|_|_|_|_|___|_|_|_|_|_|_|_|_|___|_
(0005) *this has the advantage that the pulse width can stay constant, only the periode has to be changed
(0006) *on everey compare match interrupt the periode value for the next chanel is loaded
(0007) *the last chanal value has an extra large value and is used to gennerate the sync gap
(0008) *the fist ppm train after power up is wrong so dynamic reconfiguration is used to disconect the PWM from the output PIN
(0009) *this mecanism is also used the start / stop the PPM output loading a 1 to ppm_Run will output one pulse train
(0010) *between the last pulse and the sync pulse an IO interrupt on rising edge is enabled , in the interrupt rotine 
(0011) *of this ppm_Run is cleared and the PWM is disdonected from the PIN, the PWM will stay in state PPM_PULSE_COUNT+1
(0012) * and wait that the main program will set ppm_Run again, that will start the next cycle
(0013) */
(0014) 
(0015) #include <m8c.h>        // part specific constants and macros
(0016) #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
(0017) #include "ppm.h"
(0018) 
(0019) 
(0020) volatile WORD ppm_Data[PPM_PULSE_COUNT];	//the pulse len valune for the chanales
(0021) volatile BYTE ppm_Nr=0;//the chanal counter
(0022) volatile BOOL ppm_Run=0;//start one pulse train
(0023) 
(0024) //initialize PPM output
(0025) void ppm_Init(void )
(0026) {
_ppm_Init:
  n                    --> X+0
    04FC: 10       PUSH  X
    04FD: 4F       MOV   X,SP
    04FE: 38 02    ADD   SP,0x2
(0027) 	
(0028) int n;
(0029) 	//Init PPM_DATA array
(0030) 	for (n=0;n<PPM_PULSE_COUNT;n++)
    0500: 56 01 00 MOV   [X+1],0x0
    0503: 56 00 00 MOV   [X+0],0x0
(0031) 	{	//set to center
(0032) 		ppm_Data[n]=(PPM_OUT_MIN_LEN+PPM_OUT_MAX_LEN)/2;
    0506: 52 01    MOV   A,[X+1]
    0508: 64       ASL   A
    0509: 01 1C    ADD   A,0x1C
    050B: 53 16    MOV   [__r1],A
    050D: 50 0B    MOV   A,0xB
    050F: 3F 16    MVI   [__r1],A
    0511: 50 B8    MOV   A,0xB8
    0513: 3F 16    MVI   [__r1],A
(0033) 	}
    0515: 77 01    INC   [X+1]
    0517: 0F 00 00 ADC   [X+0],0x0
    051A: 52 01    MOV   A,[X+1]
    051C: 11 08    SUB   A,0x8
    051E: 52 00    MOV   A,[X+0]
    0520: 31 80    XOR   A,0x80
    0522: 19 80    SBB   A,0x80
    0524: CF E1    JC    0x0506
(0034) 	//enable glogal interrupts
(0035) 	M8C_EnableGInt; 
    0526: 71 01    OR    F,0x1
(0036) 	//enable compare match interrupt of the PWM
(0037) 	PWM16_1_EnableInt();
    0528: 10       PUSH  X
    0529: 7C 02 63 LCALL _PWM16_1_EnableInt
    052C: 20       POP   X
(0038) 	//enable GPOI Interrupts
(0039) 	//we need that to trigger on falling egde of "compare true"
(0040) 	M8C_EnableIntMask(INT_MSK0, INT_MSK0_GPIO);
    052D: 43 E0 20 OR    REG[0xE0],0x20
(0041) 	//pulse widht is actually the small gap between the PPM pulses
(0042) 	PWM16_1_WritePulseWidth(PPM_OUT_PULSE_GAP_LEN_US);
    0530: 10       PUSH  X
    0531: 57 03    MOV   X,0x3
    0533: 50 20    MOV   A,0x20
    0535: 7C 02 71 LCALL _PWM16_1_WritePulseWidth
    0538: 20       POP   X
(0043) 	//disable IRQ on Port Pin, we do nt need iot jet
(0044) 	Port_0_4_IntEn_ADDR&=~(1<<4); 
    0539: 41 01 EF AND   REG[0x1],0xEF
(0045) 	//disconnect the PIN from the PWM and  set the pin to High
(0046) 	RDI0LT0|=0x3;
    053C: 43 B3 03 OR    REG[0xB3],0x3
(0047) 	//init pulse counter, will loop thru the canales
(0048) 	ppm_Nr=0;		
    053F: 55 01 00 MOV   [ppm_Nr|chanal],0x0
(0049) 	//set a initial pulse len, just to have somthing in ther will be change in the interrupt service
(0050) 	PWM16_1_WritePeriod(PPM_OUT_SYNC_PULSE_LEN);
    0542: 10       PUSH  X
    0543: 57 17    MOV   X,0x17
    0545: 50 70    MOV   A,0x70
    0547: 7C 02 6B LCALL _PWM16_1_WritePeriod|_PWM16_1_Stop|PWM16_1_WritePeriod
(0051) 	//start the PWM Module
(0052) 	PWM16_1_Start();
    054A: 7C 02 67 LCALL _PWM16_1_Start|_PWM16_1_DisableInt
    054D: 20       POP   X
    054E: 38 FE    ADD   SP,0xFE
    0550: 20       POP   X
    0551: 7F       RET   
(0053) }//END OFF ppm_Init
(0054) 
(0055) 
(0056) 
(0057) /*inerrupt service routine for the PWM module
(0058) *will be called on compare match
(0059) *-load pulse len of the next PPM pulse
(0060) *- increase pulse counter
(0061) *-after the last pulse (before the sync pulse is outputed enable GPOI interrupt on rising egde
(0062) *-when done wait for ppm_Run to go on again, stay in a small loop for that time
(0063) */
(0064) #pragma interrupt_handler PWM16_1_CMP_ISR
(0065) void PWM16_1_CMP_ISR(void )
(0066) {
_PWM16_1_CMP_ISR:
    0552: 08       PUSH  A
    0553: 51 17    MOV   A,[__r0]
    0555: 08       PUSH  A
    0556: 51 16    MOV   A,[__r1]
    0558: 08       PUSH  A
    0559: 51 15    MOV   A,[__r2]
    055B: 08       PUSH  A
    055C: 51 14    MOV   A,[__r3]
    055E: 08       PUSH  A
    055F: 51 13    MOV   A,[__r4]
    0561: 08       PUSH  A
    0562: 51 12    MOV   A,[__r5]
    0564: 08       PUSH  A
    0565: 51 11    MOV   A,[__r6]
    0567: 08       PUSH  A
    0568: 51 10    MOV   A,[__r7]
    056A: 08       PUSH  A
    056B: 51 0F    MOV   A,[__r8]
    056D: 08       PUSH  A
    056E: 51 0E    MOV   A,[__r9]
    0570: 08       PUSH  A
    0571: 51 0D    MOV   A,[__r10]
    0573: 08       PUSH  A
    0574: 51 0C    MOV   A,[__r11]
    0576: 08       PUSH  A
    0577: 51 0B    MOV   A,[__rX]
    0579: 08       PUSH  A
    057A: 51 0A    MOV   A,[__rY]
    057C: 08       PUSH  A
    057D: 51 09    MOV   A,[__rZ]
    057F: 08       PUSH  A
(0067) 	//if we are done wait for start (ppm_Run==1)
(0068) 	if (ppm_Nr==PPM_PULSE_COUNT+1)
    0580: 3C 01 09 CMP   [ppm_Nr|chanal],0x9
    0583: B0 22    JNZ   0x05A6
(0069) 	{
(0070) 		if (ppm_Run)
    0585: 3C 02 00 CMP   [ppm_Run|value],0x0
    0588: A0 12    JZ    0x059B
(0071) 		{ //continue with next Block of pulses
(0072) 			RDI0LT0&=~0x3;	//reconect i/O PIN to PWM
    058A: 41 B3 FC AND   REG[0xB3],0xFC
(0073) 			ppm_Nr=1;//reset counter
    058D: 55 01 01 MOV   [ppm_Nr|chanal],0x1
(0074) 			PWM16_1_WritePeriod(ppm_Data[0]);//load pulse len of first chanal
    0590: 10       PUSH  X
    0591: 58 1C    MOV   X,[ppm_Data]
    0593: 51 1D    MOV   A,[ppm_Data+1]
    0595: 7C 02 6B LCALL _PWM16_1_WritePeriod|_PWM16_1_Stop|PWM16_1_WritePeriod
    0598: 20       POP   X
(0075) 		}
    0599: 80 31    JMP   0x05CB
(0076) 		else//continue waiting
(0077) 			PWM16_1_WritePeriod(PPM_OUT_PULSE_GAP_LEN_US+10); //continue waiting
    059B: 10       PUSH  X
    059C: 57 03    MOV   X,0x3
    059E: 50 2A    MOV   A,0x2A
    05A0: 7C 02 6B LCALL _PWM16_1_WritePeriod|_PWM16_1_Stop|PWM16_1_WritePeriod
    05A3: 20       POP   X
(0078) 	}
    05A4: 80 26    JMP   0x05CB
(0079) 	//load pulse len of next chanal
(0080) 	else 
(0081) 	{	//check if that is the last chanal is done
(0082) 		if(ppm_Nr==PPM_PULSE_COUNT)
    05A6: 3C 01 08 CMP   [ppm_Nr|chanal],0x8
    05A9: B0 11    JNZ   0x05BB
(0083) 		{
(0084) 			ppm_Nr++;
    05AB: 76 01    INC   [ppm_Nr|chanal]
(0085) 			PWM16_1_WritePeriod(PPM_OUT_SYNC_PULSE_LEN); 
    05AD: 10       PUSH  X
    05AE: 57 17    MOV   X,0x17
    05B0: 50 70    MOV   A,0x70
    05B2: 7C 02 6B LCALL _PWM16_1_WritePeriod|_PWM16_1_Stop|PWM16_1_WritePeriod
    05B5: 20       POP   X
(0086) 			Port_0_4_IntEn_ADDR|=(1<<4);	//enable pin irq
    05B6: 43 01 10 OR    REG[0x1],0x10
(0087) 		}
    05B9: 80 11    JMP   0x05CB
(0088) 		else 
(0089) 		{
(0090) 			PWM16_1_WritePeriod(ppm_Data[ppm_Nr++]); 
    05BB: 5F 16 01 MOV   [__r1],[ppm_Nr|chanal]
    05BE: 06 01 01 ADD   [ppm_Nr|chanal],0x1
    05C1: 91 D9    CALL  <created procedures>
    05C3: 40       NOP   
    05C4: 10       PUSH  X
    05C5: 58 17    MOV   X,[__r0]
    05C7: 7C 02 6B LCALL _PWM16_1_WritePeriod|_PWM16_1_Stop|PWM16_1_WritePeriod
    05CA: 20       POP   X
(0091) 		}
(0092) 	}
    05CB: 18       POP   A
    05CC: 53 09    MOV   [__rZ],A
    05CE: 18       POP   A
    05CF: 53 0A    MOV   [__rY],A
    05D1: 18       POP   A
    05D2: 53 0B    MOV   [__rX],A
    05D4: 18       POP   A
    05D5: 53 0C    MOV   [__r11],A
    05D7: 18       POP   A
    05D8: 53 0D    MOV   [__r10],A
    05DA: 18       POP   A
    05DB: 53 0E    MOV   [__r9],A
    05DD: 18       POP   A
    05DE: 53 0F    MOV   [__r8],A
    05E0: 18       POP   A
    05E1: 53 10    MOV   [__r7],A
    05E3: 18       POP   A
    05E4: 53 11    MOV   [__r6],A
    05E6: 18       POP   A
    05E7: 53 12    MOV   [__r5],A
    05E9: 18       POP   A
    05EA: 53 13    MOV   [__r4],A
    05EC: 18       POP   A
    05ED: 53 14    MOV   [__r3],A
    05EF: 18       POP   A
    05F0: 53 15    MOV   [__r2],A
    05F2: 18       POP   A
    05F3: 53 16    MOV   [__r1],A
    05F5: 18       POP   A
    05F6: 53 17    MOV   [__r0],A
    05F8: 18       POP   A
    05F9: 7E       RETI  
(0093) }//END OFF PWM16_1_CMP_ISR
(0094) 
(0095) //called on a GPIO interrupt
(0096) #pragma interrupt_handler PPM_GPIO_ISR
(0097) void PPM_GPIO_ISR(void )
(0098) {
_PPM_GPIO_ISR:
    05FA: 08       PUSH  A
    05FB: 51 17    MOV   A,[__r0]
    05FD: 08       PUSH  A
(0099) 	if (PRT0DR&(1<<4)) //Check if PPM output pin went high
    05FE: 5D 00    MOV   A,REG[0x0]
    0600: 53 17    MOV   [__r0],A
    0602: 47 17 10 TST   [__r0],0x10
    0605: A0 0D    JZ    0x0613
(0100) 	{ //we are done 
(0101) 	PRT0DR^=(1<<2);
    0607: 45 00 04 XOR   REG[0x0],0x4
(0102) 		ppm_Run=0;		//signal that we are done
    060A: 55 02 00 MOV   [ppm_Run|value],0x0
(0103) 		Port_0_4_IntEn_ADDR&=~(1<<4);	//disable pin irq
    060D: 41 01 EF AND   REG[0x1],0xEF
(0104) 		RDI0LT0|=0x3;	//disconect IO pin from PWM and set to High
    0610: 43 B3 03 OR    REG[0xB3],0x3
(0105) 	}
    0613: 18       POP   A
(0106) 	
(0107) }
FILE: E:\WORKSP~1\DSM2PPM\PSOCDE~1\SATELI~2\SATELI~1\SATELI~1\serial.c
(0001) /*this module contains the code for serial reciving the data from the sattilie reciver
(0002) * a Buffer of 16 byte ist used to store recived data
(0003) * most work is doen within the interrupt sevice routine
(0004) *datarate is set in the chip design to 115200 by the devider for VC3
(0005) *the timer module will call the ser_Tic function once per ms
(0006) *if for 5ms no more chars are recived the index is reset to zerro
(0007) */
(0008) 
(0009) #include <m8c.h>        // part specific constants and macros
(0010) #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
(0011) #include "serial.h"
(0012) 
(0013) 
(0014) BYTE ser_databuf[SER_BUFFER_SIZE]; //the buffer to hold the recived data
(0015) BYTE ser_idx=0;						//index into buffer
(0016) BYTE ser_status=0;					//reciver status
(0017) BYTE ser_to=0;						//timeout variable to determin end of transmision
(0018) 
(0019) //initialize the RX8 module
(0020) void SerialRX_Init(void )
(0021) {
_SerialRX_Init:
  n                    --> X+0
    0618: 10       PUSH  X
    0619: 4F       MOV   X,SP
    061A: 38 02    ADD   SP,0x2
(0022) 	int n;
(0023) 	RX8_1_EnableInt(); //enable hardwar
    061C: 10       PUSH  X
    061D: 7C 02 4E LCALL _RX8_1_EnableInt
    0620: 20       POP   X
(0024) 	//clear buffer
(0025) 	for (n=0;n<16;n++)
    0621: 56 01 00 MOV   [X+1],0x0
    0624: 56 00 00 MOV   [X+0],0x0
(0026) 		ser_databuf[n]=0;
    0627: 52 01    MOV   A,[X+1]
    0629: 01 2D    ADD   A,0x2D
    062B: 53 16    MOV   [__r1],A
    062D: 50 00    MOV   A,0x0
    062F: 3F 16    MVI   [__r1],A
    0631: 77 01    INC   [X+1]
    0633: 0F 00 00 ADC   [X+0],0x0
    0636: 52 01    MOV   A,[X+1]
    0638: 11 10    SUB   A,0x10
    063A: 52 00    MOV   A,[X+0]
    063C: 31 80    XOR   A,0x80
    063E: 19 80    SBB   A,0x80
    0640: CF E6    JC    0x0627
(0027) 	//set index to 0
(0028) 	ser_idx=0;
    0642: 55 03 00 MOV   [ser_idx],0x0
(0029) 	//enable interrupts
(0030) 	M8C_EnableGInt;
    0645: 71 01    OR    F,0x1
(0031) 	RX8_1_EnableInt();
    0647: 10       PUSH  X
    0648: 7C 02 4E LCALL _RX8_1_EnableInt
(0032) 	//start reciving
(0033) 	RX8_1_Start(RX8_PARITY_NONE);
    064B: 50 00    MOV   A,0x0
    064D: 7C 02 52 LCALL _RX8_1_DisableInt|RX8_1_Start|_RX8_1_Start
    0650: 20       POP   X
    0651: 38 FE    ADD   SP,0xFE
    0653: 20       POP   X
    0654: 7F       RET   
(0034) }
(0035) 
(0036) //check if there is a compleet package avaliable
(0037) BOOL SerialReadData(void )
(0038) {
(0039) 	//check if status contains anny error bits
(0040) 	if (0xF0&SER_GET_STATUS())
_SerialReadData:
    0655: 47 04 F0 TST   [ser_status],0xF0
    0658: A0 0E    JZ    0x0667
(0041) 	{	//reset in case of an error
(0042) 		SER_CLEAR_ERROR();
    065A: 26 04 F0 AND   [ser_status],0xF0
(0043) 		SER_RESET();
    065D: 55 04 00 MOV   [ser_status],0x0
    0660: 55 03 00 MOV   [ser_idx],0x0
(0044) 		return 0;
    0663: 50 00    MOV   A,0x0
    0665: 80 0C    JMP   0x0672
(0045) 	}
(0046) 	//ckeck if buffer is full
(0047) 	if (SER_PEAK())
    0667: 47 04 01 TST   [ser_status],0x1
    066A: A0 05    JZ    0x0670
(0048) 	{
(0049) 		return 1;
    066C: 50 01    MOV   A,0x1
    066E: 80 03    JMP   0x0672
(0050) 	}
(0051) return 0;
    0670: 50 00    MOV   A,0x0
    0672: 7F       RET   
(0052) 
(0053) }
(0054) 
(0055) //reconnect RX8 to input pin
(0056) void SerialConnectToPin(void)
(0057) {
(0058) 	//change driver Mode to input
(0059) 	PRT0DM1|=(1<<5);
_SerialConnectToPin:
    0673: 71 10    OR    F,0x10
    0675: 43 01 20 OR    REG[0x1],0x20
(0060) 	//switch pin connection to RX8
(0061) 	PRT0DM0&=~(1<<5);
    0678: 41 00 DF AND   REG[0x0],0xDF
    067B: 70 CF    AND   F,0xCF
    067D: 7F       RET   
(0062) }
(0063) 
(0064) //this is called from the system timer once per ms
(0065) //ser_to is reset to zerro each time a char is recived by the serial interupt service
(0066) //if there has not been anny char recived for 5 consecutive calls then reset the index
(0067) void ser_Tic(void )
(0068) {
(0069) 	ser_to++; //increment timeout
_ser_Tic:
    067E: 76 05    INC   [ser_to]
(0070) 	if (ser_idx!=0 && ser_to > 5) //to we have a timeout (>5ms)
    0680: 3C 03 00 CMP   [ser_idx],0x0
    0683: A0 0A    JZ    0x068E
    0685: 50 05    MOV   A,0x5
    0687: 3A 05    CMP   A,[ser_to]
    0689: D0 04    JNC   0x068E
(0071) 		ser_idx=0; //reset index
    068B: 55 03 00 MOV   [ser_idx],0x0
    068E: 7F       RET   
(0072) }
(0073) 
(0074) #define RX8_1_RX_ENABLE 1
(0075) #pragma interrupt_handler RX8_1_Interrupt
(0076) 
(0077) //interrupt handler called if a char is recived
(0078) void RX8_1_Interrupt(void )
(0079) {
_RX8_1_Interrupt:
    068F: 08       PUSH  A
    0690: 51 17    MOV   A,[__r0]
    0692: 08       PUSH  A
    0693: 51 16    MOV   A,[__r1]
    0695: 08       PUSH  A
(0080) 	static BYTE ser_c; //the char buffer, defined as static to save stack space
(0081) 	
(0082) 	ser_to=0; //reset timeout
    0696: 55 05 00 MOV   [ser_to],0x0
    0699: 80 59    JMP   0x06F3
(0083) 
(0084) 
(0085) 	//if a char is recived 
(0086) 	//we use while instead of if because it can happen that another char is recived while we are here, 
(0087) 	//in that case no extra interrop for that one will occour
(0088) 	while (RX8_RX_COMPLETE & RX8_1_CONTROL_REG)
(0089) 	{	//get the char
(0090) 		ser_c=RX8_1_RX_BUFFER_REG;
    069B: 5D 2A    MOV   A,REG[0x2A]
    069D: 53 2C    MOV   [ppm_Data+16],A
(0091) 		//if we have no error store the char
(0092) 		if (!(RX8_1_RX_ERROR & RX8_1_CONTROL_REG))
    069F: 5D 2B    MOV   A,REG[0x2B]
    06A1: 53 17    MOV   [__r0],A
    06A3: 47 17 E0 TST   [__r0],0xE0
    06A6: B0 2B    JNZ   0x06D2
(0093) 		{
(0094) 			//if there is still room in bufffer
(0095) 			if (ser_idx<SER_BUFFER_SIZE)
    06A8: 3C 03 10 CMP   [ser_idx],0x10
    06AB: D0 21    JNC   0x06CD
(0096) 			{//store data
(0097) 				ser_databuf[ser_idx++]=ser_c;
    06AD: 5F 16 03 MOV   [__r1],[ser_idx]
    06B0: 55 17 00 MOV   [__r0],0x0
    06B3: 51 16    MOV   A,[__r1]
    06B5: 01 01    ADD   A,0x1
    06B7: 53 03    MOV   [ser_idx],A
    06B9: 06 16 2D ADD   [__r1],0x2D
    06BC: 0E 17 00 ADC   [__r0],0x0
    06BF: 51 2C    MOV   A,[ppm_Data+16]
    06C1: 3F 16    MVI   [__r1],A
(0098) 				//check if buffer is full now
(0099) 				if (ser_idx==SER_BUFFER_SIZE)
    06C3: 3C 03 10 CMP   [ser_idx],0x10
    06C6: B0 35    JNZ   0x06FC
(0100) 					ser_status|=SER_BUFFERFULL; //flag that we are done
    06C8: 2E 04 01 OR    [ser_status],0x1
(0101) 			}
    06CB: 80 30    JMP   0x06FC
(0102) 			else 
(0103) 				ser_status|=SER_BUFOVERRUN_ERROR; //flag a buffer overrun
    06CD: 2E 04 10 OR    [ser_status],0x10
(0104) 			return ;
    06D0: 80 2B    JMP   0x06FC
(0105) 		}
(0106) 		//if we got anny error
(0107) 		if(RX8_1_RX_ERROR & RX8_1_CONTROL_REG)
    06D2: 5D 2B    MOV   A,REG[0x2B]
    06D4: 53 17    MOV   [__r0],A
    06D6: 47 17 E0 TST   [__r0],0xE0
    06D9: A0 19    JZ    0x06F3
(0108) 		{
(0109) 			ser_idx=0; //reset index , trash all we have so far
    06DB: 55 03 00 MOV   [ser_idx],0x0
(0110) 			ser_status|=RX8_1_CONTROL_REG & RX8_1_RX_ERROR; //update status
    06DE: 5D 2B    MOV   A,REG[0x2B]
    06E0: 21 E0    AND   A,0xE0
    06E2: 2C 04    OR    [ser_status],A
(0111) 			//special case framing error
(0112) 			if (RX8_1_RX_FRAMING_ERROR & RX8_1_CONTROL_REG)
    06E4: 5D 2B    MOV   A,REG[0x2B]
    06E6: 53 17    MOV   [__r0],A
    06E8: 47 17 20 TST   [__r0],0x20
    06EB: A0 07    JZ    0x06F3
(0113) 			{
(0114) 				RX8_1_CONTROL_REG&=~RX8_1_RX_ENABLE; //disable RX
    06ED: 41 2B FE AND   REG[0x2B],0xFE
(0115) 				RX8_1_CONTROL_REG|=RX8_1_RX_ENABLE; //enable RX
    06F0: 43 2B 01 OR    REG[0x2B],0x1
(0116) 			}
(0117) 		}
(0118) 	}
    06F3: 5D 2B    MOV   A,REG[0x2B]
(0119) } //end of ISRFILE: E:\WORKSP~1\DSM2PPM\PSOCDE~1\SATELI~2\SATELI~1\SATELI~1\timer.c
(0001) /* this module implements the systimer
(0002) * the systic will be incremented once per ms
(0003) *also the timer is used to gennerate the bind pulses for the sttelite
(0004) *for that the hardware is reconfigured so that to serial input pin is connected to the timer output instead
(0005) */
(0006) #include <m8c.h>        // part specific constants and macros
(0007) #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
(0008) #include "timer.h"
(0009) #include "serial.h"
(0010) 
(0011) WORD systic=0;   //will be incremented once per ms
(0012) BYTE BindCount=0;  //used to gnnerate the 120us bind pulses
(0013) 
(0014) 
(0015) //initialize system timer
(0016) void TimerInit(void )
(0017) {
(0018) 	//enable interrupt
(0019) 	M8C_EnableGInt; 
_TimerInit:
    0704: 71 01    OR    F,0x1
(0020) 	Counter8_1_EnableInt();  
    0706: 10       PUSH  X
    0707: 7C 02 D7 LCALL _Counter8_1_EnableInt
(0021) 	//ser periode to one per ms
(0022) 	Counter8_1_WritePeriod(125); //one TC per ms
    070A: 50 7D    MOV   A,0x7D
    070C: 7C 02 DF LCALL _Counter8_1_WritePeriod|_Counter8_1_Stop
(0023) 	Counter8_1_WriteCompareValue(0);
    070F: 50 00    MOV   A,0x0
    0711: 7C 02 E2 LCALL _Counter8_1_WriteCompareValue
(0024) 	//start it
(0025) 	Counter8_1_Start();
    0714: 7C 02 DB LCALL _Counter8_1_Start|_Counter8_1_DisableInt
    0717: 20       POP   X
    0718: 7F       RET   
(0026) }
(0027) 
(0028) //connect the timer output to the I/O pin
(0029) void TimerConnectToPin(void)
(0030) {
(0031) 	//switch pin connection to counter8_1 compare out
(0032) 	PRT0DM0|=(1<<5);
_TimerConnectToPin:
    0719: 71 10    OR    F,0x10
    071B: 43 00 20 OR    REG[0x0],0x20
(0033) 	//change driver Mode to Output
(0034) 	PRT0DM1&=~(1<<5);
    071E: 41 01 DF AND   REG[0x1],0xDF
    0721: 70 CF    AND   F,0xCF
    0723: 7F       RET   
(0035) 	//set number of bind pulses to gennerate
(0036) }
(0037) 
(0038) //gennerate the bind pulses for the satelite reciver
(0039) void Timer_GennerateBindPulses(BYTE Pulese)
(0040) {
_Timer_GennerateBindPulses:
  Pulese               --> X-4
    0724: 10       PUSH  X
    0725: 4F       MOV   X,SP
(0041) 	TimerConnectToPin();
    0726: 9F F1    CALL  _TimerConnectToPin
(0042) 	BindCount=Pulese+1;
    0728: 52 FC    MOV   A,[X-4]
    072A: 01 01    ADD   A,0x1
    072C: 53 08    MOV   [BindCount],A
(0043) 	while (BindCount); //wait till done
    072E: 3C 08 00 CMP   [BindCount],0x0
    0731: BF FC    JNZ   0x072E
(0044) 	//waite a bite more
(0045) 	TimerWait_ms(100);
    0733: 50 64    MOV   A,0x64
    0735: 08       PUSH  A
    0736: 90 07    CALL  _TimerWait_ms
    0738: 38 FF    ADD   SP,0xFF
(0046) 	SerialConnectToPin();
    073A: 7C 06 73 LCALL _SerialConnectToPin
    073D: 20       POP   X
    073E: 7F       RET   
(0047) }
(0048) 
(0049) //a delay
(0050) void TimerWait_ms(BYTE ms)
(0051) {
_TimerWait_ms:
  time                 --> X+0
  ms                   --> X-4
    073F: 10       PUSH  X
    0740: 4F       MOV   X,SP
    0741: 38 02    ADD   SP,0x2
(0052) WORD time;
(0053) 	time = TMR_GET_SYSTIC();
    0743: 51 07    MOV   A,[systic+1]
    0745: 54 01    MOV   [X+1],A
    0747: 51 06    MOV   A,[systic]
    0749: 54 00    MOV   [X+0],A
(0054) 	while (TMR_GET_TIME_DELTA(time)<ms);
    074B: 52 FC    MOV   A,[X-4]
    074D: 53 16    MOV   [__r1],A
    074F: 55 17 00 MOV   [__r0],0x0
    0752: 51 07    MOV   A,[systic+1]
    0754: 13 01    SUB   A,[X+1]
    0756: 53 14    MOV   [__r3],A
    0758: 51 06    MOV   A,[systic]
    075A: 1B 00    SBB   A,[X+0]
    075C: 53 15    MOV   [__r2],A
    075E: 51 14    MOV   A,[__r3]
    0760: 12 16    SUB   A,[__r1]
    0762: 51 15    MOV   A,[__r2]
    0764: 1A 17    SBB   A,[__r0]
    0766: CF E4    JC    0x074B
    0768: 38 FE    ADD   SP,0xFE
    076A: 20       POP   X
    076B: 7F       RET   
(0055) }
(0056) 
(0057) void TMR8_1_Interrupt(void )
(0058) {
(0059) 	//the bind pulses are gennerated by the timer
(0060) 	if (BindCount)
_TMR8_1_Interrupt:
    076C: 3C 08 00 CMP   [BindCount],0x0
    076F: A0 22    JZ    0x0792
(0061) 	{
(0062) 		Counter8_1_WriteCompareValue(15); //120us
    0771: 10       PUSH  X
    0772: 50 0F    MOV   A,0xF
    0774: 7C 02 E2 LCALL _Counter8_1_WriteCompareValue
(0063) 		Counter8_1_WritePeriod(30); //240 us
    0777: 50 1E    MOV   A,0x1E
    0779: 7C 02 DF LCALL _Counter8_1_WritePeriod|_Counter8_1_Stop
    077C: 20       POP   X
(0064) 		BindCount--;
    077D: 7A 08    DEC   [BindCount]
(0065) 		if(!BindCount)
    077F: 3C 08 00 CMP   [BindCount],0x0
    0782: B0 14    JNZ   0x0797
(0066) 		{ //back to normal operation 
(0067) 			Counter8_1_WriteCompareValue(0);
    0784: 10       PUSH  X
    0785: 50 00    MOV   A,0x0
    0787: 7C 02 E2 LCALL _Counter8_1_WriteCompareValue
(0068) 			Counter8_1_WritePeriod(250);
    078A: 50 FA    MOV   A,0xFA
    078C: 7C 02 DF LCALL _Counter8_1_WritePeriod|_Counter8_1_Stop
    078F: 20       POP   X
(0069) 		}
(0070) 	}
    0790: 80 06    JMP   0x0797
(0071) 	else 
(0072) 	{
(0073) 		systic++;
    0792: 76 07    INC   [systic+1]
    0794: 0E 06 00 ADC   [systic],0x0
(0074) 		
(0075) 	}
    0797: 7F       RET   
FILE: lib\psocgpioint.asm               (0001) ;  Generated by PSoC Designer 5.4.2946
                                        (0002) ;
                                        (0003) ;;*****************************************************************************
                                        (0004) ;;*****************************************************************************
                                        (0005) ;;  FILENAME: PSoCGPIOINT.asm
                                        (0006) ;;   Version: 2.0.0.20, Updated on 2003/07/17 at 12:10:35
                                        (0007) ;;  @PSOC_VERSION
                                        (0008) ;;
                                        (0009) ;;  DESCRIPTION: PSoC GPIO Interrupt Service Routine
                                        (0010) ;;-----------------------------------------------------------------------------
                                        (0011) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0012) ;;*****************************************************************************
                                        (0013) ;;*****************************************************************************
                                        (0014) 
                                        (0015) include "m8c.inc"
                                        (0016) include "PSoCGPIOINT.inc"
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export   PSoC_GPIO_ISR
                                        (0022) 
                                        (0023) 
                                        (0024) ;-----------------------------------------------
                                        (0025) ;  Constant Definitions
                                        (0026) ;-----------------------------------------------
                                        (0027) 
                                        (0028) 
                                        (0029) ;-----------------------------------------------
                                        (0030) ; Variable Allocation
                                        (0031) ;-----------------------------------------------
                                        (0032) 	
                                        (0033) 
                                        (0034) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0035) ;---------------------------------------------------
                                        (0036) ; Insert your custom declarations below this banner
                                        (0037) ;---------------------------------------------------
                                        (0038) 
                                        (0039) ;---------------------------------------------------
                                        (0040) ; Insert your custom declarations above this banner
                                        (0041) ;---------------------------------------------------
                                        (0042) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0043) 
                                        (0044) 
                                        (0045) ;-----------------------------------------------------------------------------
                                        (0046) ;  FUNCTION NAME: PSoC_GPIO_ISR
                                        (0047) ;
                                        (0048) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0049) ;
                                        (0050) ;-----------------------------------------------------------------------------
                                        (0051) ;
                                        (0052) PSoC_GPIO_ISR:
                                        (0053) 
                                        (0054) 
                                        (0055)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0056)    ;---------------------------------------------------
                                        (0057)    ; Insert your custom code below this banner
                                        (0058)    ;---------------------------------------------------
                                        (0059)    ;include "memory.inc"
                                        (0060)    ;PRESERVE_CPU_CONTEXT
0798: 8E 61    JMP   _PPM_GPIO_ISR      (0061)    ljmp _PPM_GPIO_ISR
                                        (0062)    ;RESTORE_CPU_CONTEXT
                                        (0063)    ;---------------------------------------------------
                                        (0064)    ; Insert your custom code above this banner
                                        (0065)    ;---------------------------------------------------
                                        (0066)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0067) 
079A: 7E       RETI                     (0068)    reti
                                        (0069) 
                                        (0070) 
                                        (0071) ; end of file PSoCGPIOINT.asm
    079B: 30       HALT  
<created procedures>:
    079C: 65 16    ASL   [__r1]
    079E: 06 16 1C ADD   [__r1],0x1C
    07A1: 3E 16    MVI   A,[__r1]
    07A3: 53 17    MOV   [__r0],A
    07A5: 3E 16    MVI   A,[__r1]
    07A7: 7F       RET   
    07A8: 52 00    MOV   A,[X+0]
    07AA: 64       ASL   A
    07AB: 01 2F    ADD   A,0x2F
    07AD: 53 16    MOV   [__r1],A
    07AF: 3E 16    MVI   A,[__r1]
    07B1: 67       ASR   A
    07B2: 67       ASR   A
    07B3: 7F       RET   
